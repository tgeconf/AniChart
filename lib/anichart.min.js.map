{"version":3,"sources":["webpack://anichart/webpack/universalModuleDefinition","webpack://anichart/webpack/bootstrap","webpack://anichart/./src/TimingSpec.js","webpack://anichart/./src/util/Util.js","webpack://anichart/./src/Animation.js","webpack://anichart/./src/ChartSpec.js","webpack://anichart/./src/FacetSpec.js","webpack://anichart/./src/index.js","webpack://anichart/./src/ActionSpec.js","webpack://anichart/./src/GroupingSpec.js","webpack://anichart/./src/AniChart.js","webpack://anichart/./src/Renderer.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","TimingSpec","this","_offset","_reference","timingRef","previousStart","refStr","previousEnd","absolute","lastStart","lastEnd","allItemsStart","domMarks","Map","size","itemStart","reference","offset","that","itemsStart","minAttrValue","forEach","attrs","markId","parseFloat","field","offsetValue","minOffset","set","offsetRef","tmpOffsetRefStr","transRef","keys","includes","alert","ofst","Math","floor","FRAME_RATE","Util","obj","objType","result","Array","isArray","length","deepClone","time","currentTimeS","parseInt","currentTimeMS","color","toLowerCase","from","colorNames","replace","indexOf","tmpStr","substr","rgb","substring","split","HEX2RGB","hex","charAt","g","b","values","toString","node","nodeType","tagName","nodeName","nodeValue","attributes","attr","JSON","parse","document","createElementNS","attrValue","stringify","setAttributeNS","createTextNode","createComment","implementation","createDocument","createDocumentType","createDocumentFragment","discretizeD","fill","fillColor","resultGroup","reg","group","undefined","exec","reduce","push","slice","index","map","x","command","parameters","filter","trim","every","convertColor","lines","prev","valid","firstPoint","secondPoint","v","type","data","circles","svgArcToCenterParam","apply","concat","rx","ry","rotate","abs","cx","cy","startAngle","endAngle","radius","ux","uy","vx","vy","dot","mod","sqrt","rad","acos","x1","y1","phi","fA","fS","x2","y2","deltaAngle","PIx2","PI","Error","s_phi","sin","c_phi","cos","hd_x","hd_y","hs_x","hs_y","x1_","y1_","lambda","rxry","rxy1_","ryx1_","sum_of_sq","coe","cx_","cy_","xcr1","xcr2","ycr1","ycr2","radian","clockwise","str","fMode","tMode","mr","startsWith","match","padStart","join","centerX","centerY","angleInRadians","round","y","innerRadius","outterRadius","largeArcFlag","start1","polarToCartesian","end1","start2","end2","isRing","domNode","element","createElement","appendChild","innerHTML","tmpDiv","firstChild","tx","ty","hasPosi","getAttribute","setAttribute","resultCmd","setPathDValue","reset","diffCmds","cmdRegExp","RegExp","cmds","firstCmdName","resetX","resetY","firstCmdValues","cmdName","cmdValue","calNumTrans","nums","ni","nums2","anums","anums2","currentCmdIdx","resetVal","tVal","diffCmdIdxs","flag","j","cmdIdx","startD","endD","ratio","startDisD","endDisD","len","fromStartAngle","fromEndAngle","toStartAngle","toEndAngle","interpolateFn","validAngle","e","minimalAngle","interpolate","markStatus","statusArr","tmpDRecorder","compareD","dArr","firstD","firstDCmds","tmpD","tmpDCmds","diffAttrIdxs","firstDCmdValues","tmpDCmdValue","firstDCmdValue","tmpDCmdValues","hasFlag","Set","dom","tr","scaleStr","transStr","transPosiStr","scaleNumStr","transNums","scaleNum","test","Animation","chartIdx","selection","grouping","actions","animationStartTime","animationEndTime","allMarkAni","wholeEndTime","startTime","totalDuration","item","maskActionByAttr","markActionByAttr","actionAttrs","actionTargets","mark","attribute","attrName","mask","console","log","actionList","tmpAction0","animationType","duration","tmpAction","to","a","timePoint","frame","currentStatus","resultValue","calAttrValue","endTime","percentage","calRatio","easing","fromColor","toColor","fromRGB","color2RGB","toRGB","startValue","isNaN","finalValue","finalStatus","minStatus","startY","startX","tmpAngle","_startAngle","_endAngle","startRadius","endRadius","tmpRadius","finalDashOffset","startDiscretVal","finalDiscretVal","calTransD","easingType","easeLinear","easeInQuad","easeFuncs","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeOutBounce","clear","frames","animationJson","usedChangedAttrs","checkFormat","initGrouping","actionJson","visAttrActionJson","visAttrActionJsonArr","transToVisualAttrAction","dataTrans","initAction","markIds","lastAnimation","durationAttrValues","action","tmpAttrValues","datum","minDuration","calActionDuration","actionsDurations","minValueEachAttr","processedActions","marksInOrder","arrangeOrder","markAni","groupByMap","vAttr","tmpObj","visualAttrs","pow","calTimeInGrouping","tmpAllStart","timeDiff","calOffsetTime","tmpActionSpec","offsetStart","currentStartTime","currentEndTime","tmpEndTime","endX","ChartSpec","id","source","chartSpecs","facet","nameCharts","charts","nullCharts","xhr","XMLHttpRequest","okStatus","location","protocol","svgContent","open","overrideMimeType","send","status","responseText","children","unshift","facetViews","removeTransitions","mergeCharts","views","chartsToCombine","tmpRecorder","chartName","cloneNode","combineCharts","facetType","facetNum","resultCharts","tmpCharts","oriWidth","oriHeight","viewBoxNums","viewBoxW","viewBoxH","chartTransForm","getTransformAttrs","row","col","tmpChart","tmpMarks","querySelectorAll","idNum","classList","add","chartChildren","tmpDom","transformAttrs","allMarks","markTempletes","attrNames","nullStatus","marks","statusObj","outerHTML","changedAttrs","attrNamesCopy","compareStatus","splice","findDiffCmds","markDoms","markStr","targetValue","resultD","textContent","svgMark","DOMParser","parseFromString","lastChild","querySelector","dataTransArr","si","tmpStatus","getElementById","bBoxes","bBox","getBBox","width","parentTrans","parentNode","transShape","svg","markBoundingRects","height","chartStr","aniSvg","aniMarks","am","idIndex","rect","rect2","FacetSpec","_type","_views","maxLen","lastItem","numDiff","require","AniChart","Renderer","aniChart","frameRate","loadSpec","url","callback","renderSpec","spec","aniChartObj","init","render","play","renderFrame","resetCover","resetAll","ActionSpec","actionTypes","appear","_easing","_duration","actionJsonArr","changedAttr","fromArr","toArr","transArr","tmpFromItem","tmpToItem","tmpFromPath","tmpToPath","fromPathStepLen","getTotalLength","toPathStepLen","fromDiscritPath","toDiscritPath","tmpFromPnt","getPointAtLength","tmpToPnt","preObj","transition","targetAnimationType","custom","fade","fadeOut","wipeBottom","wipe","wipeOutFromTop","wipeTop","move","wipeOutFromBottom","wipeLeft","wipeOutFromRight","wipeRight","wipeOutFromLeft","wheel","wheelOut","circle","circleOut","grow","degrow","zoom","tmpObj2","actionArr","wholeStart","wholeEnd","durationWithAttr","tmpStartMap","tmpEndMap","mistake","tmpStart","minTmpStart","maxTmpEnd","tmpEnd","tmpResultDuration","resultDurations","tmpExtraDuration","tp","es","drtn","GroupingSpec","_groupBy","_delay","sort","order","expr","groupingJson","groupBy","delay","generateTree","getMarkOrder","groupByRef","nodesThisLevel","refValue","groupRef","hasSingleMark","ref","orderRef","nodesThisLevelArr","orderType","markId1","markId2","orderRefValue1","orderRefValue2","datum1","datum2","orderTypes","ascending","descending","random","tmpNode","orderedMarks","queue","shift","ani","firstItemLastGroup","lastItemLastGroup","groupByArr","currentGroupRef","currentGroup","lastGroup","updateGroupingTime","markAniArr","entries","previousStartTime","previousEndTime","maxDurationItemLastGroup","itemLastGroup","maxDuration","gb","tmpRefStr","dly","_animations","loadCharts","svgChart","removeTransAndMerge","getBBoxes","animateChart","processAnimateChart","animations","aniIdx","tmpContainer","body","animation","translate","contains","markJSON","toJSON","transformedAttrs","discretizePath","tfAttrsDataKeys","tAttr","toDOM","tmpDomAttrObj","attrArr","markDom","dataDatumAttrValue","calAniTime","removeChild","renderAnimation","aniJson","idxAniJson","tmpAni","chartNum","tmpAniJson","tmpIdxAniJson","ctime","singleStatus","aniId","checkHTML","strToDomNode","getAttributeNS","aniMarkBgId","currentAniMarkBBox","testAniMCover","aniMCover","generateMaskCover","coverTypes","arc","wedge","path","coverType","updateAttrName","updateAttrValue","maskCover","animaskCovers","mc","animationInterval","setInterval","locatedFrame","clearInterval"],"mappings":"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","file":"anichart.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"anichart\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"anichart\"] = factory();\n\telse\n\t\troot[\"anichart\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","class TimingSpec {\r\n    constructor() {\r\n        this._offset = 0;//default offfset is 0\r\n        this._reference = TimingSpec.timingRef.previousStart;//default offset reference is 'previous_start'\r\n    }\r\n\r\n    /***** getters and setters *****/\r\n    set reference(offsetRef) {\r\n        if (typeof offsetRef !== 'undefined') {\r\n            let tmpOffsetRefStr = TimingSpec.transRef(offsetRef);\r\n            if (Object.keys(TimingSpec.timingRef).includes(tmpOffsetRefStr)) {\r\n                this._reference = offsetRef;\r\n            } else {\r\n                alert('the \\'reference\\' of TimingSpec has to be one of \\'previousStart\\', \\'previousEnd\\' or \\'absolute\\'. ')\r\n            }\r\n        }\r\n    }\r\n\r\n    get reference() {\r\n        return this._reference;\r\n    }\r\n\r\n    set offset(ofst) {\r\n        if (typeof ofst !== 'undefined') {\r\n            if (typeof ofst === 'number') {\r\n                this._offset = Math.floor(ofst / (1000 / TimingSpec.FRAME_RATE)) * (1000 / TimingSpec.FRAME_RATE);\r\n            } else if (typeof ofst === 'object') {\r\n                this._offset = ofst;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    get offset() {\r\n        return this._offset;\r\n    }\r\n    /***** end getters and setters *****/\r\n\r\n    /**\r\n     * add offset start time\r\n     * @param {number} lastStart : start time of the last item\r\n     * @param {number} lastEnd : end time of the last item\r\n     * @param {number} allItemsStart : start time of all the items \r\n     * @param {Map} domMarks : key: markId, value: attrs\r\n     */\r\n    calOffsetTime(lastStart, lastEnd, allItemsStart = 0, domMarks = new Map()) {\r\n        if (domMarks.size === 0) {//computing action offset time, return a number\r\n            let itemStart = 0;\r\n            switch (this.reference) {\r\n                case TimingSpec.timingRef.previousStart:\r\n                    itemStart = lastStart + this.offset - allItemsStart;\r\n                    break;\r\n                case TimingSpec.timingRef.previousEnd:\r\n                    itemStart = lastEnd + this.offset - allItemsStart;\r\n                    break;\r\n                case TimingSpec.timingRef.absolute:\r\n                    itemStart = this.offset + allItemsStart;\r\n                    break;\r\n                default:\r\n                    itemStart = lastStart + this.offset - allItemsStart;\r\n            }\r\n            return itemStart;\r\n        } else {//computing animation offset time, return a map\r\n            let that = this;\r\n            let itemsStart = new Map();\r\n\r\n            //if the offset is an object, find the min value of the field in offset\r\n            let minAttrValue = 1000000;\r\n            if (typeof this.offset === 'object') {\r\n                domMarks.forEach(function (attrs, markId) {\r\n                    if (minAttrValue > parseFloat(attrs['data-datum'][that.offset.field])) {\r\n                        minAttrValue = parseFloat(attrs['data-datum'][that.offset.field]);\r\n                    }\r\n                })\r\n            }\r\n\r\n            domMarks.forEach(function (attrs, markId) {\r\n                let offsetValue = 0;\r\n                //judge the type of offset: number or object\r\n                if (typeof that.offset === 'number') {\r\n                    offsetValue = that.offset;\r\n                } else if (typeof that.offset === 'object') {\r\n                    offsetValue = that.offset.minOffset * parseFloat(attrs['data-datum'][that.offset.field]) / minAttrValue;\r\n                } else {\r\n                    offsetValue = 0;\r\n                }\r\n\r\n                switch (that.reference) {\r\n                    case TimingSpec.timingRef.previousStart:\r\n                        itemsStart.set(markId, lastStart + offsetValue - allItemsStart);\r\n                        break;\r\n                    case TimingSpec.timingRef.previousEnd:\r\n                        itemsStart.set(markId, lastEnd + offsetValue - allItemsStart);\r\n                        break;\r\n                    case TimingSpec.timingRef.absolute:\r\n                        itemsStart.set(markId, offsetValue + allItemsStart);\r\n                        break;\r\n                    default:\r\n                        itemsStart.set(markId, lastStart + offsetValue - allItemsStart);\r\n                }\r\n            })\r\n            return itemsStart;\r\n        }\r\n\r\n    }\r\n\r\n    static transRef(refStr){\r\n        switch (refStr){\r\n            case this.timingRef.previousStart:\r\n                return 'previousStart';\r\n            case this.timingRef.previousEnd:\r\n                return 'previousEnd';\r\n            case this.timingRef.absolute:\r\n                return 'absolute';\r\n        }\r\n    }\r\n}\r\n\r\nTimingSpec.FRAME_RATE = 20;\r\nTimingSpec.timingRef = {\r\n    previousStart: 'start with previous',\r\n    previousEnd: 'start after previous',\r\n    absolute: 'absolute'\r\n};\r\n\r\nexport default TimingSpec;","class Util {\r\n    constructor() { }\r\n\r\n    static deepClone(obj) {\r\n        if (!obj || true == obj) //this also handles boolean as true and false\r\n            return obj;\r\n        var objType = typeof (obj);\r\n        if (\"number\" == objType || \"string\" == objType) // add your immutables here\r\n            return obj;\r\n        var result = Array.isArray(obj) ? [] : {};\r\n        if (obj instanceof Map) {\r\n            result = new Map();\r\n            for (let i = 0; i < obj.keys().length; i++) {\r\n                let key = obj.keys()[i];\r\n                result.set(key, Util.deepClone(obj.get(key)));\r\n            }\r\n        }\r\n        for (var key in obj)\r\n            if (obj.hasOwnProperty(key))\r\n                result[key] = Util.deepClone(obj[key]);\r\n        return result;\r\n    }\r\n\r\n    static formatTime(time) {\r\n        let currentTimeS = parseInt(time / 1000);\r\n        let currentTimeMS = parseInt(time % 1000 / 10);\r\n        let currentTimeSStr = currentTimeS < 10 ? '0' + currentTimeS : '' + currentTimeS;\r\n        let currentTimeMSStr = currentTimeMS < 10 ? '0' + currentTimeMS : '' + currentTimeMS;\r\n        return currentTimeSStr + ':' + currentTimeMSStr;\r\n    }\r\n\r\n    static color2RGB(color) {\r\n        color = color.toLowerCase();\r\n        if (Array.from(this.colorNames.keys()).includes(color)) {\r\n            color = this.colorNames.get(color);\r\n        }\r\n        color = color.replace(/\\s/g, '');\r\n        if (color.indexOf('rgb') >= 0) {\r\n            let tmpStr = color.substr(color.indexOf('(') + 1);\r\n            tmpStr = tmpStr.substring(0, tmpStr.indexOf(')'));\r\n            let rgb = tmpStr.split(',');\r\n            if (rgb.length === 3) {\r\n                rgb[3] = 255;\r\n            }\r\n            return [parseInt(rgb[0]), parseInt(rgb[1]), parseInt(rgb[2]), parseInt(rgb[3])];\r\n        } else if (color.indexOf('#') >= 0) {\r\n            return this.HEX2RGB(color);\r\n        }\r\n        return [255, 255, 255, 0];\r\n    }\r\n\r\n    static HEX2RGB(hex) {\r\n        if (hex.charAt(0) === '#') {\r\n            hex = hex.substr(1);\r\n        }\r\n        if ((hex.length < 2) || (hex.length > 6)) {\r\n            return false;\r\n        }\r\n        let values = hex.split(''),\r\n            r,\r\n            g,\r\n            b,\r\n            a = 255;\r\n\r\n        if (hex.length === 2) {\r\n            r = parseInt(values[0].toString() + values[1].toString(), 16);\r\n            g = r;\r\n            b = r;\r\n        } else if (hex.length === 3) {\r\n            r = parseInt(values[0].toString() + values[0].toString(), 16);\r\n            g = parseInt(values[1].toString() + values[1].toString(), 16);\r\n            b = parseInt(values[2].toString() + values[2].toString(), 16);\r\n        } else if (hex.length === 6) {\r\n            r = parseInt(values[0].toString() + values[1].toString(), 16);\r\n            g = parseInt(values[2].toString() + values[3].toString(), 16);\r\n            b = parseInt(values[4].toString() + values[5].toString(), 16);\r\n        } else {\r\n            return false;\r\n        }\r\n        return [r, g, b, a];\r\n    }\r\n\r\n    static toJSON(node) {\r\n        node = node || this;\r\n        let obj = {\r\n            nodeType: node.nodeType\r\n        };\r\n        if (node.tagName) {\r\n            obj.tagName = node.tagName.toLowerCase();\r\n        } else\r\n            if (node.nodeName) {\r\n                obj.nodeName = node.nodeName;\r\n            }\r\n        if (node.nodeValue) {\r\n            obj.nodeValue = node.nodeValue;\r\n        }\r\n        let attrs = node.attributes;\r\n        if (attrs) {\r\n            obj.attr = {};\r\n            for (let i = 0, attr; i < attrs.length | (attr = attrs[i]); i++) {\r\n                obj.attr[attr.nodeName] = attr.nodeValue;\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    static toDOM(obj) {\r\n        if (typeof obj == 'string') {\r\n            obj = JSON.parse(obj);\r\n        }\r\n        let node, nodeType = obj.nodeType;\r\n        switch (nodeType) {\r\n            case 1: //ELEMENT_NODE\r\n                node = document.createElementNS('http://www.w3.org/2000/svg', obj.tagName);\r\n                let attributes = obj.attr || {};\r\n                for (let i = 0, attr; i < Object.keys(attributes).length | (attr = Object.keys(attributes)[i]); i++) {\r\n                    let attrValue = typeof attributes[attr] === 'object' ? JSON.stringify(attributes[attr], null, 0) : attributes[attr];\r\n                    node.setAttributeNS(null, attr, attrValue);\r\n                }\r\n                break;\r\n            case 3: //TEXT_NODE\r\n                node = document.createTextNode(obj.nodeValue);\r\n                break;\r\n            case 8: //COMMENT_NODE\r\n                node = document.createComment(obj.nodeValue);\r\n                break;\r\n            case 9: //DOCUMENT_NODE\r\n                node = document.implementation.createDocument();\r\n                break;\r\n            case 10: //DOCUMENT_TYPE_NODE\r\n                node = document.implementation.createDocumentType(obj.nodeName);\r\n                break;\r\n            case 11: //DOCUMENT_FRAGMENT_NODE\r\n                node = document.createDocumentFragment();\r\n                break;\r\n            default:\r\n                return node;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * @param {*} obj A parsed svg json object.\r\n     */\r\n    static discretizePath(obj) {\r\n        // normalize attributes\r\n        if (obj.tagName !== 'path') return null\r\n        let attr = obj.attr || {}\r\n        if (!attr.d) return null\r\n        return Util.discretizeD(attr.d, attr.fill);\r\n    }\r\n\r\n    static discretizeD(d, fillColor) {\r\n        let resultGroup = [],\r\n            reg = /[MmLlHhVvZzCcSsQqTtAa][^MmLlHhVvZzCcSsQqTtAa]*/gi,\r\n            group = undefined;\r\n        while ((group = reg.exec(d))) {\r\n            let offset = resultGroup.reduce((p, c) => p + c.length, 0);\r\n            resultGroup.push(d.slice(offset, group.index));\r\n            resultGroup.push(group[0]);\r\n        }\r\n        let result = resultGroup\r\n            .map(x => {\r\n                let command = x.slice(0, 1);\r\n                let parameters = x\r\n                    .slice(1)\r\n                    .split(/[ ,]/)\r\n                    .filter(n => n.trim())\r\n                    .map(n => parseFloat(n));\r\n                return command ? {\r\n                    command,\r\n                    parameters\r\n                } : null;\r\n            }).filter(x => x)\r\n        // polyline style path\r\n        if (result.every(x => 'MmLlHhVv'.includes(x.command)) && !Util.convertColor(fillColor)) {\r\n            let lines = []\r\n            let prev = null\r\n            let valid = true\r\n            result.forEach(x => {\r\n                if (!valid) return\r\n                if (x.command === 'M') {\r\n                    prev = x.parameters.slice(-2)\r\n                    return\r\n                }\r\n                if (!prev) return valid = false\r\n                if (x.command === 'm') {\r\n                    prev = prev.map((v, i) => v + x.parameters[i])\r\n                    return\r\n                }\r\n                let firstPoint = prev,\r\n                    secondPoint = x.command === x.command.toLowerCase() ? prev.slice() : [0, 0]\r\n                switch (x.command.toLowerCase()) {\r\n                    case 'l':\r\n                        secondPoint = secondPoint.map((v, i) => v + x.parameters[i])\r\n                        break\r\n                    case 'h':\r\n                        secondPoint[0] += x.parameters[0]\r\n                        secondPoint[1] = firstPoint[1]\r\n                        break\r\n                    case 'v':\r\n                        secondPoint[1] += x.parameters[0]\r\n                        secondPoint[0] = firstPoint[0]\r\n                        break\r\n                }\r\n                if (secondPoint) {\r\n                    lines.push([firstPoint, secondPoint])\r\n                    prev = secondPoint\r\n                } else {\r\n                    valid = false\r\n                }\r\n            })\r\n            if (valid) return {\r\n                type: 'lines',\r\n                data: lines\r\n            }\r\n        }\r\n        // pie style path\r\n        if (result.every(x => 'MmLlAaZz'.includes(x.command)) && result.filter(x => x.command.toLowerCase() === 'a').length) {\r\n            let circles = []\r\n            let prev = null\r\n            let valid = true\r\n            result.forEach(x => {\r\n                if (!valid) return\r\n                if (x.command.toLowerCase() === 'm') {\r\n                    prev = x.parameters.slice(-2)\r\n                    return\r\n                }\r\n                if (!prev) return valid = false\r\n                if (x.command.toLowerCase() === 'z') return\r\n                let firstPoint = prev,\r\n                    secondPoint = x.command.toLowerCase() === x.command ? prev.slice() : [0, 0]\r\n                if (x.command.toLowerCase() !== 'a') {\r\n                    return prev = secondPoint.map((v, i) => v + x.parameters[i])\r\n                }\r\n                secondPoint = secondPoint.map((v, i) => v + x.parameters[i + 5])\r\n                circles.push({\r\n                    ...Util.svgArcToCenterParam.apply(null, firstPoint.concat(x.parameters.slice(0, 5)).concat(secondPoint)),\r\n                    rx: x.parameters[0],\r\n                    ry: x.parameters[1],\r\n                    rotate: x.parameters[2]\r\n                })\r\n                prev = secondPoint\r\n            })\r\n            if (circles.length <= 0 || !circles.every(x => ['cx', 'cy'].reduce((p, c) => p + Math.abs(x[c] - circles[0][c]), 0) < 1e-1)) valid = false\r\n            if (valid) {\r\n                let c = circles.reduce((p, c) => {\r\n                    if (!p) return c\r\n                    if (c.rx + c.ry > p.rx + p.ry) return c\r\n                    return p\r\n                }, null)\r\n                let attrResult = {\r\n                    type: 'pies',\r\n                    data: {\r\n                        cx: c.cx,\r\n                        cy: c.cy,\r\n                        startAngle: c.startAngle,\r\n                        endAngle: c.endAngle,\r\n                        radius: circles.map(x => {\r\n                            return {\r\n                                rx: x.rx,\r\n                                ry: x.ry,\r\n                                rotate: x.rotate\r\n                            }\r\n                        })\r\n                    }\r\n                }\r\n                return attrResult;\r\n            }\r\n        }\r\n        // other unhandled style path\r\n        return null\r\n    }\r\n\r\n    static radian(ux, uy, vx, vy) {\r\n        var dot = ux * vx + uy * vy;\r\n        var mod = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));\r\n        var rad = Math.acos(dot / mod);\r\n        if (ux * vy - uy * vx < 0.0) {\r\n            rad = -rad;\r\n        }\r\n        return rad;\r\n    }\r\n\r\n    static svgArcToCenterParam(x1, y1, rx, ry, phi, fA, fS, x2, y2) {\r\n        var cx, cy, startAngle, deltaAngle, endAngle;\r\n        var PIx2 = Math.PI * 2.0;\r\n\r\n        if (rx < 0) {\r\n            rx = -rx;\r\n        }\r\n        if (ry < 0) {\r\n            ry = -ry;\r\n        }\r\n        if (rx == 0.0 || ry == 0.0) { // invalid arguments\r\n            throw Error('rx and ry can not be 0');\r\n        }\r\n\r\n        var s_phi = Math.sin(phi);\r\n        var c_phi = Math.cos(phi);\r\n        var hd_x = (x1 - x2) / 2.0; // half diff of x\r\n        var hd_y = (y1 - y2) / 2.0; // half diff of y\r\n        var hs_x = (x1 + x2) / 2.0; // half sum of x\r\n        var hs_y = (y1 + y2) / 2.0; // half sum of y\r\n\r\n        // F6.5.1\r\n        var x1_ = c_phi * hd_x + s_phi * hd_y;\r\n        var y1_ = c_phi * hd_y - s_phi * hd_x;\r\n\r\n        // F.6.6 Correction of out-of-range radii\r\n        //   Step 3: Ensure radii are large enough\r\n        var lambda = (x1_ * x1_) / (rx * rx) + (y1_ * y1_) / (ry * ry);\r\n        if (lambda > 1) {\r\n            rx = rx * Math.sqrt(lambda);\r\n            ry = ry * Math.sqrt(lambda);\r\n        }\r\n\r\n        var rxry = rx * ry;\r\n        var rxy1_ = rx * y1_;\r\n        var ryx1_ = ry * x1_;\r\n        var sum_of_sq = rxy1_ * rxy1_ + ryx1_ * ryx1_; // sum of square\r\n        if (!sum_of_sq) {\r\n            throw Error('start point can not be same as end point');\r\n        }\r\n        var coe = Math.sqrt(Math.abs((rxry * rxry - sum_of_sq) / sum_of_sq));\r\n        if (fA == fS) {\r\n            coe = -coe;\r\n        }\r\n\r\n        // F6.5.2\r\n        var cx_ = coe * rxy1_ / ry;\r\n        var cy_ = -coe * ryx1_ / rx;\r\n\r\n        // F6.5.3\r\n        cx = c_phi * cx_ - s_phi * cy_ + hs_x;\r\n        cy = s_phi * cx_ + c_phi * cy_ + hs_y;\r\n\r\n        var xcr1 = (x1_ - cx_) / rx;\r\n        var xcr2 = (x1_ + cx_) / rx;\r\n        var ycr1 = (y1_ - cy_) / ry;\r\n        var ycr2 = (y1_ + cy_) / ry;\r\n\r\n        // F6.5.5\r\n        startAngle = Util.radian(1.0, 0.0, xcr1, ycr1);\r\n\r\n        // F6.5.6\r\n        deltaAngle = Util.radian(xcr1, ycr1, -xcr2, -ycr2);\r\n        while (deltaAngle > PIx2) {\r\n            deltaAngle -= PIx2;\r\n        }\r\n        while (deltaAngle < 0.0) {\r\n            deltaAngle += PIx2;\r\n        }\r\n        if (fS == false || fS == 0) {\r\n            deltaAngle -= PIx2;\r\n        }\r\n        endAngle = startAngle + deltaAngle;\r\n        while (endAngle > PIx2) {\r\n            endAngle -= PIx2;\r\n        }\r\n        while (endAngle < 0.0) {\r\n            endAngle += PIx2;\r\n        }\r\n\r\n        var outputObj = {\r\n            /* cx, cy, startAngle, deltaAngle */\r\n            cx,\r\n            cy,\r\n            startAngle,\r\n            deltaAngle,\r\n            endAngle,\r\n            clockwise: (fS == true || fS == 1)\r\n        }\r\n\r\n        return outputObj;\r\n    }\r\n\r\n    static convertColor(str, fMode, tMode) {\r\n        if (typeof str !== 'string') return str\r\n        if (str === 'none') return null\r\n        str = str.trim()\r\n        let mr = null\r\n        if (tMode === undefined) {\r\n            tMode = fMode\r\n            if (str.startsWith('#')) {\r\n                fMode = 'hex'\r\n            } else if (str.startsWith('rgb')) {\r\n                fMode = 'rgb'\r\n            }\r\n        }\r\n        // assume user input is valid\r\n        switch (fMode) {\r\n            case 'rgb':\r\n                mr = str.split('(')[1].split(',').map(x => parseFloat(x))\r\n                break\r\n            case 'hex':\r\n                mr = str.slice(1).match(/.{1,2}/g).map(x => parseInt(x, 16))\r\n            default:\r\n                return str\r\n        }\r\n        mr = mr.slice(0, 3)\r\n        switch (tMode) {\r\n            case 'hex':\r\n                return '#' + mr.map(x => x.toString(16).padStart(2, '0')).join('')\r\n            case 'rgb':\r\n                return `rgb(${mr.join(',')})`\r\n            default:\r\n                return str\r\n        }\r\n    }\r\n\r\n    static polarToCartesian(centerX, centerY, radius, angleInRadians) {\r\n        return {\r\n            x: Math.round((centerX + (radius * Math.cos(angleInRadians))) * 100) / 100,\r\n            y: Math.round((centerY + (radius * Math.sin(angleInRadians))) * 100) / 100\r\n        };\r\n    };\r\n\r\n    static arc(x, y, innerRadius, outterRadius, startAngle, endAngle) {\r\n        startAngle = startAngle < 0 ? startAngle + 2 * Math.PI : startAngle;\r\n        endAngle = endAngle < 0 || startAngle > endAngle ? endAngle + 2 * Math.PI : endAngle;\r\n\r\n        //to generate cover, make the cover a little bigger\r\n        innerRadius = innerRadius === 0 ? 0 : innerRadius - 1;\r\n        outterRadius += 1;\r\n\r\n        let largeArcFlag = endAngle - startAngle <= Math.PI ? 0 : 1;\r\n\r\n        let start1 = Util.polarToCartesian(x, y, outterRadius, endAngle);\r\n        let end1 = Util.polarToCartesian(x, y, outterRadius, startAngle);\r\n        let start2 = Util.polarToCartesian(x, y, innerRadius, endAngle);\r\n        let end2 = Util.polarToCartesian(x, y, innerRadius, startAngle);\r\n\r\n        let isRing = false;\r\n        if (start1.x === end1.x && start1.y === end1.y) {//this is a ring\r\n            end1.y -= 1;\r\n            end2.y -= 1;\r\n            isRing = true;\r\n        }\r\n\r\n        let d;\r\n        if (!isRing) {\r\n            d = [\r\n                \"M\" + start1.x, start1.y,\r\n                \"A\" + outterRadius, outterRadius, 0, largeArcFlag, 0, end1.x, end1.y,\r\n                \"L\" + end2.x, end2.y,\r\n                \"A\" + innerRadius, innerRadius, 0, largeArcFlag, 1, start2.x, start2.y,\r\n                \"L\" + start1.x, start1.y + \"Z\"\r\n            ].join(\",\");\r\n        } else {\r\n            d = [\r\n                \"M\" + start1.x, start1.y,\r\n                \"A\" + outterRadius, outterRadius, 0, largeArcFlag, 1, end1.x, end1.y,\r\n                \"M\" + end2.x, end2.y,\r\n                \"A\" + innerRadius, innerRadius, 0, largeArcFlag, 0, start2.x, start2.y + \"Z\"\r\n            ].join(\",\");\r\n        }\r\n\r\n        return d;\r\n    };\r\n\r\n    /**\r\n     * turn a dom node to string\r\n     * @param {DOM} domNode \r\n     */\r\n    static domNodeToString(domNode) {\r\n        var element = document.createElement(\"div\");\r\n        element.appendChild(domNode);\r\n        return element.innerHTML;\r\n    }\r\n\r\n    /**\r\n     * turn a string to dom node\r\n     * @param {string} str \r\n     */\r\n    static strToDomNode(str) {\r\n        let tmpDiv = document.createElement('div');\r\n        tmpDiv.innerHTML = str.trim();\r\n        let dom = tmpDiv.firstChild;\r\n        return dom;\r\n    }\r\n\r\n    static transShape(t, tx, ty) {\r\n        if (t.tagName !== 'path') {\r\n            let hasPosi = false;\r\n            if (t.getAttribute('x') || t.getAttribute('y')) {\r\n                hasPosi = true;\r\n                t.setAttribute('x', t.getAttribute('x') ? parseFloat(t.getAttribute('x')) + tx : tx);\r\n                t.setAttribute('y', t.getAttribute('y') ? parseFloat(t.getAttribute('y')) + ty : ty);\r\n            }\r\n            if (t.getAttribute('x1') || t.getAttribute('y1') || t.getAttribute('x2') || t.getAttribute('y2')) {\r\n                hasPosi = true;\r\n                t.setAttribute('x1', t.getAttribute('x1') ? parseFloat(t.getAttribute('x1')) + tx : tx);\r\n                t.setAttribute('x2', t.getAttribute('x2') ? parseFloat(t.getAttribute('x2')) + tx : tx);\r\n                t.setAttribute('y1', t.getAttribute('y1') ? parseFloat(t.getAttribute('y1')) + ty : ty);\r\n                t.setAttribute('y2', t.getAttribute('y2') ? parseFloat(t.getAttribute('y2')) + ty : ty);\r\n            }\r\n            if (t.getAttribute('cx') || t.getAttribute('cy')) {\r\n                hasPosi = true;\r\n                t.setAttribute('cx', t.getAttribute('cx') ? parseFloat(t.getAttribute('cx')) + tx : tx);\r\n                t.setAttribute('cy', t.getAttribute('cy') ? parseFloat(t.getAttribute('cy')) + ty : ty);\r\n            }\r\n            if (!hasPosi) {\r\n                if (t.tagName === 'circle') {\r\n                    t.setAttribute('cx', tx);\r\n                    t.setAttribute('cy', ty);\r\n                } else {\r\n                    t.setAttribute('x', tx);\r\n                    t.setAttribute('y', ty);\r\n                }\r\n            }\r\n        } else {\r\n            if (t.getAttribute('d')) {\r\n                let resultCmd = Util.setPathDValue(t.getAttribute('d'), false, tx, ty);\r\n                t.setAttribute('d', resultCmd);\r\n            }\r\n        }\r\n    }\r\n    static setPathDValue(d, reset, tx = 0, ty = 0, diffCmds = new Map()) {\r\n        d = d.replace(/(?<=\\d)\\s(?=[mMlLhHvVcCsSqQtTaAzZ])/g, '').replace(/(?<=[mMlLhHvVcCsSqQtTaA])\\s(?=(\\d|[-+]))/g, '').replace(/\\s/g, ',');\r\n        let cmdRegExp = new RegExp(/[mMlLhHvVcCsSqQtTaA][^mMlLhHvVcCsSqQtTaAzZ]*/g);\r\n        let resultCmd = '';\r\n        let cmds = d.match(cmdRegExp);\r\n        if (cmds) {\r\n            //get the position of the first move cmd if there is one\r\n            let firstCmdName = cmds[0].substring(0, 1);\r\n            let resetX = '0', resetY = '0';\r\n            if (firstCmdName === 'm' || firstCmdName === 'M') {\r\n                let firstCmdValues = cmds[0].substring(1).split(',');\r\n                resetX = firstCmdValues[0];\r\n                resetY = firstCmdValues[1];\r\n            }\r\n\r\n            for (let i = 0; i < cmds.length; i++) {\r\n                let cmdName = cmds[i].substring(0, 1);\r\n                let cmdValue = cmds[i].substring(1);\r\n                resultCmd += cmdName;\r\n                switch (cmdName) {\r\n                    case 'H':\r\n                        resultCmd = this.calNumTrans(resultCmd, diffCmds, i, cmdName, cmdValue, reset, resetX, tx);\r\n                        break;\r\n                    case 'h':\r\n                        resultCmd = this.calNumTrans(resultCmd, diffCmds, i, cmdName, cmdValue, reset, '0', 0);\r\n                        break;\r\n                    case 'V':\r\n                        resultCmd = this.calNumTrans(resultCmd, diffCmds, i, cmdName, cmdValue, reset, resetY, ty);\r\n                        break;\r\n                    case 'v':\r\n                        resultCmd = this.calNumTrans(resultCmd, diffCmds, i, cmdName, cmdValue, reset, '0', 0);\r\n                        break;\r\n                    case 'M':\r\n                    case 'L':\r\n                    case 'T':\r\n                    case 'C':\r\n                    case 'S':\r\n                    case 'Q':\r\n                        let nums = cmdValue.split(',');\r\n                        for (let ni = 0; ni < nums.length; ni++) {\r\n                            if (ni % 2 === 0) {//x\r\n                                resultCmd = this.calNumTrans(resultCmd, diffCmds, i, cmdName, nums[ni], reset, resetX, tx);\r\n                            } else {//y\r\n                                resultCmd = this.calNumTrans(resultCmd, diffCmds, i, cmdName, nums[ni], reset, resetY, ty);\r\n                            }\r\n                            if (ni !== nums.length - 1) {\r\n                                resultCmd += ',';\r\n                            }\r\n                        }\r\n                        break;\r\n                    case 'm':\r\n                    case 'l':\r\n                    case 't':\r\n                    case 'c':\r\n                    case 's':\r\n                    case 'q':\r\n                        let nums2 = cmdValue.split(',');\r\n                        for (let ni = 0; ni < nums2.length; ni++) {\r\n                            resultCmd = this.calNumTrans(resultCmd, diffCmds, i, cmdName, nums2[ni], reset, '0', 0);\r\n                            if (ni !== nums2.length - 1) {\r\n                                resultCmd += ',';\r\n                            }\r\n                        }\r\n                        break;\r\n                    case 'A':\r\n                        let anums = cmdValue.split(',');\r\n                        for (let ni = 0; ni < anums.length; ni++) {\r\n                            if (ni === anums.length - 2) {//x\r\n                                resultCmd = this.calNumTrans(resultCmd, diffCmds, i, cmdName, anums[ni], reset, parseFloat(resetX) + 1, tx);\r\n                                resultCmd += ',';\r\n                            } else if (ni === anums.length - 1) {//y\r\n                                resultCmd = this.calNumTrans(resultCmd, diffCmds, i, cmdName, anums[ni], reset, parseFloat(resetY) + 1, ty);\r\n                            } else {\r\n                                resultCmd += anums[ni] + ',';\r\n                            }\r\n                        }\r\n                        break;\r\n                    case 'a':\r\n                        let anums2 = cmdValue.split(',');\r\n                        for (let ni = 0; ni < anums2.length; ni++) {\r\n                            if (ni === anums2.length - 2) {//x\r\n                                resultCmd = this.calNumTrans(resultCmd, diffCmds, i, cmdName, anums2[ni], reset, '1', 0);\r\n                                resultCmd += ',';\r\n                            } else if (ni === anums2.length - 1) {//y\r\n                                resultCmd = this.calNumTrans(resultCmd, diffCmds, i, cmdName, anums2[ni], reset, '1', 0);\r\n                            } else {\r\n                                resultCmd += anums2[ni] + ',';\r\n                            }\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            if (d.charAt(d.length - 1) === 'z' || d.charAt(d.length - 1) === 'Z') {\r\n                resultCmd += 'Z';\r\n            }\r\n        }\r\n        return resultCmd;\r\n    }\r\n\r\n    static calNumTrans(resultCmd, diffCmds, currentCmdIdx, cmdName, cmdValue, reset, resetVal, tVal) {\r\n        cmdName = cmdName.toLowerCase();\r\n        if (reset) {\r\n            if (typeof diffCmds.get(cmdName) !== 'undefined') {\r\n                let diffCmdIdxs = diffCmds.get(cmdName);\r\n                let flag = false;\r\n                for (let j = 0; j < diffCmdIdxs.length; j++) {\r\n                    if (diffCmdIdxs[j].cmdIdx === currentCmdIdx) {\r\n                        resultCmd += resetVal;\r\n                        flag = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!flag) {\r\n                    resultCmd += cmdValue;\r\n                }\r\n            } else {\r\n                resultCmd += cmdValue;\r\n            }\r\n        } else {\r\n            resultCmd += (parseFloat(cmdValue) + tVal);\r\n        }\r\n        return resultCmd;\r\n    }\r\n\r\n    /**\r\n     * doing transition with path\r\n     * @param {*} startD \r\n     * @param {*} endD \r\n     * @param {*} ratio \r\n     */\r\n    static calTransD(startD, endD, ratio, startDisD, endDisD) {\r\n        startD = startD.replace(/(?<=\\d)\\s(?=[mMlLhHvVcCsSqQtTaAzZ])/g, '').replace(/(?<=[mMlLhHvVcCsSqQtTaA])\\s(?=(\\d|[-+]))/g, '').replace(/\\s/g, ',');\r\n        endD = endD.replace(/(?<=\\d)\\s(?=[mMlLhHvVcCsSqQtTaAzZ])/g, '').replace(/(?<=[mMlLhHvVcCsSqQtTaA])\\s(?=(\\d|[-+]))/g, '').replace(/\\s/g, ',');\r\n        let resultCmd = '';\r\n        if (ratio === 0) {\r\n            resultCmd = startD;\r\n        } else if (ratio === 1) {\r\n            resultCmd = endD;\r\n        } else {\r\n            for (let i = 0, len = startDisD.length; i < len; i++) {\r\n                resultCmd += (i === 0 ? 'M' : 'L') + ((endDisD[i][0] - startDisD[i][0]) * ratio + startDisD[i][0]) + ',' + ((endDisD[i][1] - startDisD[i][1]) * ratio + startDisD[i][1]);\r\n            }\r\n        }\r\n        \r\n        if (startD.charAt(startD.length - 1) === 'z' || startD.charAt(startD.length - 1) === 'Z') {\r\n            resultCmd += 'Z';\r\n        }\r\n        return resultCmd;\r\n    }\r\n\r\n    /** startAngle should smaller than endAngle\r\n     * @param {number} fromStartAngle start state of start angle\r\n     * @param {number} fromEndAngle start state of end angle\r\n     * @param {number} toStartAngle end state of start angle\r\n     * @param {number} toEndAngle end state of end angle\r\n     * @param {number} ratio 0-1 float number\r\n     * @param {Function<number,number,number>} interpolateFn customize interpolate function, input is (start, end, ratio), default is linear\r\n     * @returns {Array<number>} [startAngle, endAngle] of given ratio\r\n     */\r\n    static arcTransition(fromStartAngle, fromEndAngle, toStartAngle, toEndAngle, ratio, interpolateFn) {\r\n        let validAngle = (s, e) => e < s ? (() => { throw 'startAngle should smaller than endAngle' })() : null\r\n        validAngle(fromStartAngle, fromEndAngle)\r\n        validAngle(toStartAngle, toEndAngle)\r\n        let minimalAngle = (s, e) => e - Math.PI * 2 * Math.floor((e - s) / Math.PI / 2)\r\n        // uniform angle domain within 2*PI\r\n        fromEndAngle = minimalAngle(fromStartAngle, fromEndAngle)\r\n        toStartAngle = minimalAngle(fromStartAngle, toStartAngle)\r\n        toEndAngle = minimalAngle(toStartAngle, toEndAngle)\r\n        // find the cloest domain\r\n        toStartAngle -= Math.abs(toStartAngle - fromStartAngle) + Math.abs(toEndAngle - fromEndAngle) < 2 * Math.PI ? 0 : Math.PI * 2\r\n        toEndAngle = minimalAngle(toStartAngle, toEndAngle)\r\n        let interpolate = interpolateFn || ((s, e, r) => r * (e - s) + s)\r\n        return [interpolate(fromStartAngle, toStartAngle, ratio), interpolate(fromEndAngle, toEndAngle, ratio)]\r\n    }\r\n\r\n    static findDiffCmds(markStatus) {\r\n        let result = new Map();\r\n        markStatus.forEach((statusArr, markId) => {\r\n            let tmpDRecorder = [];\r\n            for (let i = 0; i < statusArr.length; i++) {\r\n                if (typeof statusArr[i] !== 'undefined') {\r\n                    tmpDRecorder.push(!statusArr[i].d ? 'm0,0' : statusArr[i].d);\r\n                }\r\n            }\r\n            if (tmpDRecorder.length > 0) {\r\n                Util.compareD(tmpDRecorder, result);\r\n            }\r\n        })\r\n        return result;\r\n    }\r\n\r\n    static compareD(dArr, result) {\r\n        let cmdRegExp = new RegExp(/[mlhvcsqta][^mlhvcsqtaz]*/g);\r\n        let firstD = dArr[0];\r\n        firstD = firstD.toLowerCase();\r\n        firstD = firstD.replace(/(?<=\\d)\\s(?=[mlhvcsqtaz])/g, '').replace(/(?<=[mlhvcsqta])\\s(?=(\\d|[-+]))/g, '').replace(/\\s/g, ',');\r\n        let firstDCmds = firstD.match(cmdRegExp);\r\n        for (let i = 1; i < dArr.length; i++) {\r\n            let tmpD = dArr[i];\r\n            tmpD = tmpD.toLowerCase();\r\n            tmpD = tmpD.replace(/(?<=\\d)\\s(?=[mlhvcsqtaz])/g, '').replace(/(?<=[mlhvcsqta])\\s(?=(\\d|[-+]))/g, '').replace(/\\s/g, ',');\r\n            let tmpDCmds = tmpD.match(cmdRegExp);\r\n            for (let j = 0; j < firstDCmds.length; j++) {\r\n                if (typeof tmpDCmds[j] === 'undefined') {\r\n                    let cmdName = firstDCmds[j].substring(0, 1);\r\n                    if (typeof result.get(cmdName) === 'undefined') {\r\n                        result.set(cmdName, []);\r\n                    }\r\n                    let obj = {};\r\n                    obj.cmdIdx = j;\r\n                    obj.diffAttrIdxs = [];\r\n                    let firstDCmdValue = firstDCmds[j].substring(1);\r\n                    let firstDCmdValues = firstDCmdValue.split(',');\r\n                    for (let m = 0; m < firstDCmdValues.length; m++) {\r\n                        obj.diffAttrIdxs.push(m);\r\n                    }\r\n                    result.get(cmdName).push(obj);\r\n                } else {\r\n                    let cmdName = tmpDCmds[j].substring(0, 1);\r\n                    let tmpDCmdValue = tmpDCmds[j].substring(1);\r\n                    let firstDCmdValue = firstDCmds[j].substring(1);\r\n                    if (tmpDCmdValue !== firstDCmdValue) {\r\n                        if (typeof result.get(cmdName) === 'undefined') {\r\n                            result.set(cmdName, []);\r\n                        }\r\n                        let obj = {};\r\n                        obj.cmdIdx = j;\r\n                        obj.diffAttrIdxs = [];\r\n                        let tmpDCmdValues = tmpDCmdValue.split(',');\r\n                        let firstDCmdValues = firstDCmdValue.split(',');\r\n                        for (let m = 0; m < tmpDCmdValues.length; m++) {\r\n                            if (Math.floor(parseFloat(tmpDCmdValues[m]) * 1000) !== Math.floor(parseFloat(firstDCmdValues[m]) * 1000)) {\r\n                                obj.diffAttrIdxs.push(m);\r\n                            }\r\n                        }\r\n                        //check whether have already added this cmd\r\n                        let hasFlag = false;\r\n                        for (let m = 0; m < result.get(cmdName).length; m++) {\r\n                            if (result.get(cmdName)[m].cmdIdx === obj.cmdIdx) {\r\n                                hasFlag = true;\r\n                                result.get(cmdName)[m].diffAttrIdxs = [...new Set([...result.get(cmdName)[m].diffAttrIdxs, ...obj.diffAttrIdxs])];\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!hasFlag) {\r\n                            result.get(cmdName).push(obj);\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    static getTransformAttrs(dom) {\r\n        let tr = dom.getAttribute('transform');\r\n        if (tr) {\r\n            tr = tr.replace(/translate|scale|rotate|\\s/g, (m) => {\r\n                return m === ' ' ? '' : '@' + m;\r\n            });\r\n            tr = tr.replace(/(^@*)|(@*$)/g, '').split('@');\r\n            let scaleStr = '', transStr = '';\r\n            for (let i = 0; i < tr.length; i++) {\r\n                if (tr[i].indexOf('translate') >= 0) {\r\n                    transStr = tr[i];\r\n                } else if (tr[i].indexOf('scale') >= 0) {\r\n                    scaleStr = tr[i];\r\n                }\r\n            }\r\n            let transPosiStr = ['0', '0'], scaleNumStr = '1';\r\n            if (transStr !== '') {\r\n                transPosiStr = transStr.replace(/translate\\(| |\\)/g, '').split(',');\r\n            }\r\n            if (scaleStr !== '') {\r\n                scaleNumStr = scaleStr.replace(/scale\\(| |\\)/g, '');\r\n            }\r\n            return { transNums: [parseFloat(transPosiStr[0]), parseFloat(transPosiStr[1])], scaleNum: parseFloat(scaleNumStr) };\r\n        }\r\n        return { transNums: [0.0, 0.0], scaleNum: 1.0 };\r\n    }\r\n\r\n    /**\r\n     * check if a string contains html tag\r\n     */\r\n    static checkHTML(str){\r\n        var reg = /<[^>]+>/g;\r\n        return reg.test(str);\r\n    }\r\n}\r\n\r\nUtil.colorNames = new Map([['aliceblue', '#f0f8ff'], ['antiquewhite', '#faebd7'], ['aqua', '#00ffff'], ['aquamarine', '#7fffd4'], ['azure', '#f0ffff'], ['beige', '#f5f5dc'], ['bisque', '#ffe4c4'], ['black', '#000000'], ['blanchedalmond', '#ffebcd'], ['blue', '#0000ff'], ['blueviolet', '#8a2be2'], ['brown', '#a52a2a'], ['burlywood', '#deb887'], ['cadetblue', '#5f9ea0'], ['chartreuse', '#7fff00'], ['chocolate', '#d2691e'], ['coral', '#ff7f50'], ['cornflowerblue', '#6495ed'], ['cornsilk', '#fff8dc'], ['crimson', '#dc143c'], ['cyan', '#00ffff'], ['darkblue', '#00008b'], ['darkcyan', '#008b8b'], ['darkgoldenrod', '#b8860b'], ['darkgray', '#a9a9a9'], ['darkgrey', '#a9a9a9'], ['darkgreen', '#006400'], ['darkkhaki', '#bdb76b'], ['darkmagenta', '#8b008b'], ['darkolivegreen', '#556b2f'], ['darkorange', '#ff8c00'], ['darkorchid', '#9932cc'], ['darkred', '#8b0000'], ['darksalmon', '#e9967a'], ['darkseagreen', '#8fbc8f'], ['darkslateblue', '#483d8b'], ['darkslategray', '#2f4f4f'], ['darkslategrey', '#2f4f4f'], ['darkturquoise', '#00ced1'], ['darkviolet', '#9400d3'], ['deeppink', '#ff1493'], ['deepskyblue', '#00bfff'], ['dimgray', '#696969'], ['dimgrey', '#696969'], ['dodgerblue', '#1e90ff'], ['firebrick', '#b22222'], ['floralwhite', '#fffaf0'], ['forestgreen', '#228b22'], ['fuchsia', '#ff00ff'], ['gainsboro', '#dcdcdc'], ['ghostwhite', '#f8f8ff'], ['gold', '#ffd700'], ['goldenrod', '#daa520'], ['gray', '#808080'], ['grey', '#808080'], ['green', '#008000'], ['greenyellow', '#adff2f'], ['honeydew', '#f0fff0'], ['hotpink', '#ff69b4'], ['indianred ', '#cd5c5c'], ['indigo  ', '#4b0082'], ['ivory', '#fffff0'], ['khaki', '#f0e68c'], ['lavender', '#e6e6fa'], ['lavenderblush', '#fff0f5'], ['lawngreen', '#7cfc00'], ['lemonchiffon', '#fffacd'], ['lightblue', '#add8e6'], ['lightcoral', '#f08080'], ['lightcyan', '#e0ffff'], ['lightgoldenrodyellow', '#fafad2'], ['lightgray', '#d3d3d3'], ['lightgrey', '#d3d3d3'], ['lightgreen', '#90ee90'], ['lightpink', '#ffb6c1'], ['lightsalmon', '#ffa07a'], ['lightseagreen', '#20b2aa'], ['lightskyblue', '#87cefa'], ['lightslategray', '#778899'], ['lightslategrey', '#778899'], ['lightsteelblue', '#b0c4de'], ['lightyellow', '#ffffe0'], ['lime', '#00ff00'], ['limegreen', '#32cd32'], ['linen', '#faf0e6'], ['magenta', '#ff00ff'], ['maroon', '#800000'], ['mediumaquamarine', '#66cdaa'], ['mediumblue', '#0000cd'], ['mediumorchid', '#ba55d3'], ['mediumpurple', '#9370db'], ['mediumseagreen', '#3cb371'], ['mediumslateblue', '#7b68ee'], ['mediumspringgreen', '#00fa9a'], ['mediumturquoise', '#48d1cc'], ['mediumvioletred', '#c71585'], ['midnightblue', '#191970'], ['mintcream', '#f5fffa'], ['mistyrose', '#ffe4e1'], ['moccasin', '#ffe4b5'], ['navajowhite', '#ffdead'], ['navy', '#000080'], ['oldlace', '#fdf5e6'], ['olive', '#808000'], ['olivedrab', '#6b8e23'], ['orange', '#ffa500'], ['orangered', '#ff4500'], ['orchid', '#da70d6'], ['palegoldenrod', '#eee8aa'], ['palegreen', '#98fb98'], ['paleturquoise', '#afeeee'], ['palevioletred', '#db7093'], ['papayawhip', '#ffefd5'], ['peachpuff', '#ffdab9'], ['peru', '#cd853f'], ['pink', '#ffc0cb'], ['plum', '#dda0dd'], ['powderblue', '#b0e0e6'], ['purple', '#800080'], ['rebeccapurple', '#663399'], ['red', '#ff0000'], ['rosybrown', '#bc8f8f'], ['royalblue', '#4169e1'], ['saddlebrown', '#8b4513'], ['salmon', '#fa8072'], ['sandybrown', '#f4a460'], ['seagreen', '#2e8b57'], ['seashell', '#fff5ee'], ['sienna', '#a0522d'], ['silver', '#c0c0c0'], ['skyblue', '#87ceeb'], ['slateblue', '#6a5acd'], ['slategray', '#708090'], ['slategrey', '#708090'], ['snow', '#fffafa'], ['springgreen', '#00ff7f'], ['steelblue', '#4682b4'], ['tan', '#d2b48c'], ['teal', '#008080'], ['thistle', '#d8bfd8'], ['tomato', '#ff6347'], ['turquoise', '#40e0d0'], ['violet', '#ee82ee'], ['wheat', '#f5deb3'], ['white', '#ffffff'], ['whitesmoke', '#f5f5f5'], ['yellow', '#ffff00'], ['yellowgreen', '#9acd32']])\r\n\r\nexport default Util;","import ChartSpec from './ChartSpec.js';\r\nimport ActionSpec from './ActionSpec.js';\r\nimport GroupingSpec from './GroupingSpec.js';\r\nimport TimingSpec from './TimingSpec.js';\r\nimport Util from './util/Util.js';\r\n\r\nclass Animation extends TimingSpec {\r\n    constructor() {\r\n        super();\r\n        this.chartIdx;\r\n        this.selection;\r\n        this.grouping = new GroupingSpec();\r\n        this.actions = [];\r\n\r\n        //save all dom attrs of the marks selected in this animation\r\n        this.domMarks = new Map();//key: markId, value: dom attrs\r\n        this.animationStartTime = 1000000;\r\n        this.animationEndTime = 0;\r\n    }\r\n\r\n    /**\r\n     * translate from json object to Animation object\r\n     * @param {JSON obj} animationJson \r\n     */\r\n    translate(animationJson, usedChangedAttrs) {\r\n        if (this.checkFormat(animationJson)) {\r\n            this.chartIdx = animationJson.chartIdx;\r\n            this.selection = animationJson.selection;//init selection\r\n            this.reference = animationJson.reference;\r\n            this.offset = animationJson.offset;\r\n            if (typeof animationJson.grouping !== 'undefined') {//init grouping\r\n                this.grouping.initGrouping(animationJson.grouping);\r\n            }\r\n\r\n            //translate action specs in the animation Json\r\n            if (typeof animationJson.actions !== 'undefined') {//init actions\r\n                for (let i = 0, actionJson; i < animationJson.actions.length | (actionJson = animationJson.actions[i]); i++) {\r\n                    actionJson.chartIdx = animationJson.chartIdx;\r\n                    let visAttrActionJsonArr = ActionSpec.transToVisualAttrAction(actionJson, animationJson.chartIdx, usedChangedAttrs, ChartSpec.dataTrans);//translate templates to no-templates\r\n                    for (let j = 0, visAttrActionJson; j < visAttrActionJsonArr.length | (visAttrActionJson = visAttrActionJsonArr[j]); j++) {\r\n                        let tmpAction = new ActionSpec();\r\n                        tmpAction.initAction(visAttrActionJson);\r\n                        this.actions.push(tmpAction);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * check if the input json format is illegal\r\n     * @param {JSON obj} animationJson \r\n     */\r\n    checkFormat(animationJson) {\r\n        let keys = Object.keys(animationJson);\r\n        if (keys.includes('selection')) {\r\n            return true;\r\n        }\r\n        alert('illegal format, no \\'selection\\' is defined ');\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * calculate timing for each mark;\r\n     * @param {Array} markIds : array of mark ids\r\n     * @param {Animation} lastAnimation : last animation in order to calculate time\r\n     */\r\n    calAniTime(markIds, lastAnimation) {\r\n        let that = this;\r\n\r\n        //check whether the durations of the actions are set with the data variables\r\n        let durationAttrValues = new Map();\r\n        for (let i = 0, markId; i < markIds.length | (markId = markIds[i]); i++) {\r\n            let tmpAttrValues = new Map();\r\n            for (let j = 0, action; j < this.actions.length | (action = this.actions[j]); j++) {\r\n                if (typeof action.duration === 'object') {\r\n                    let datum = this.domMarks.get(markId)['data-datum'];\r\n                    let value = parseFloat(datum[action.duration.field]);\r\n                    let minDuration = typeof action.duration.minDuration == 'undefined' ? 300 : action.duration.minDuration;\r\n                    tmpAttrValues.set(action.duration.field, [value, minDuration]);\r\n                }\r\n            }\r\n            durationAttrValues.set(markId, tmpAttrValues);\r\n        }\r\n\r\n        //calculate the duration of all actions\r\n        let [actionsDurations, minValueEachAttr, processedActions] = ActionSpec.calActionDuration(this.actions, durationAttrValues, this.domMarks);\r\n\r\n        //order the marks according to \"sort\"\r\n        let marksInOrder = this.grouping.arrangeOrder(markIds, this.domMarks);\r\n\r\n        let markAni = new Map();//the time specs and action specs of each mark, for now using Map, check later to see whether it is worthy to change to Array\r\n        let groupByMap = new Map();//record the result of groupBy. key:markId, value:group reference\r\n\r\n        for (let i = 0, markId; i < marksInOrder.length | (markId = marksInOrder[i]); i++) {\r\n            //record visual status of all marks\r\n            let tmpObj = {};\r\n            for (let j = 0, vAttr; j < Animation.visualAttrs.length | (vAttr = Animation.visualAttrs[j]); j++) {\r\n                if (typeof this.domMarks.get(markId)[vAttr] === 'undefined') {\r\n                    switch (vAttr) {\r\n                        case 'opacity'://give default opacity 1\r\n                            tmpObj[vAttr] = 1;\r\n                            break;\r\n                        case 'width'://use the width of the bounding box \r\n                            tmpObj[vAttr] = this.domMarks.get(markId)['bbWidth'];\r\n                            break;\r\n                        case 'height'://use the height of the bounding box \r\n                            tmpObj[vAttr] = this.domMarks.get(markId)['bbHeight'];\r\n                            break;\r\n                        case 'x'://use the position x of the bounding box \r\n                            tmpObj[vAttr] = this.domMarks.get(markId)['bbX'];\r\n                            break;\r\n                        case 'y'://use the position y of the bounding box \r\n                            tmpObj[vAttr] = this.domMarks.get(markId)['bbY'];\r\n                            break;\r\n                        case 'cx'://use the center of the bounding box \r\n                            tmpObj[vAttr] = this.domMarks.get(markId)['bbX'] + this.domMarks.get(markId)['bbWidth'] / 2;\r\n                            break;\r\n                        case 'cy'://use the center of the bounding box \r\n                            tmpObj[vAttr] = this.domMarks.get(markId)['bbY'] + this.domMarks.get(markId)['bbHeight'] / 2;\r\n                            break;\r\n                        case 'innerRadius'://give default inner radius 0\r\n                            tmpObj[vAttr] = 0\r\n                            break;\r\n                        case 'outterRadius'://use half of the diagonal line of the bounding box\r\n                            tmpObj[vAttr] = Math.sqrt(Math.pow(this.domMarks.get(markId)['bbWidth'] / 2, 2) + Math.pow(this.domMarks.get(markId)['bbHeight'] / 2, 2));\r\n                            break;\r\n                        case 'startAngle':\r\n                            tmpObj[vAttr] = 0;\r\n                            break;\r\n                        case 'endAngle':\r\n                            tmpObj[vAttr] = Math.PI * 2;\r\n                            break;\r\n                    }\r\n                } else {\r\n                    tmpObj[vAttr] = this.domMarks.get(markId)[vAttr];\r\n                }\r\n\r\n                if (tmpObj[vAttr] !== '') {\r\n                    if (typeof Animation.minStatus.get(vAttr) === 'undefined') {\r\n                        Animation.minStatus.set(vAttr, tmpObj[vAttr]);\r\n                    } else {\r\n                        if (parseFloat(Animation.minStatus.get(vAttr)) > parseFloat(tmpObj[vAttr])) {\r\n                            Animation.minStatus.set(vAttr, tmpObj[vAttr]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (typeof Animation.finalStatus.get(markId) === 'undefined') {\r\n                Animation.finalStatus.set(markId, []);\r\n            }\r\n            Animation.finalStatus.get(markId).push(tmpObj);\r\n\r\n            markAni.set(markId, {\r\n                'startTime': 0, //start time of this mark \r\n                'totalDuration': actionsDurations.get(markId), //total duration of all the actions of this mark\r\n                'actionAttrs': [] //action attributes of this mark\r\n            });\r\n\r\n            groupByMap.set(markId, 'allMarks');\r\n        }\r\n\r\n        this.grouping.calTimeInGrouping(markAni, this.domMarks);\r\n\r\n        //update time according to the time spec of animation\r\n        let tmpAllStart = 10000;\r\n        markAni.forEach(function (value, markId) {\r\n            if (value.startTime < tmpAllStart) {\r\n                tmpAllStart = value.startTime;\r\n            }\r\n        })\r\n\r\n        let timeDiff = typeof lastAnimation === 'undefined' ? this.calOffsetTime(0, 0, tmpAllStart, this.domMarks) : this.calOffsetTime(lastAnimation.animationStartTime, lastAnimation.animationEndTime, tmpAllStart, this.domMarks);\r\n\r\n        markAni.forEach(function (value, markId) {\r\n            let tmpObj = { 'startTime': value.startTime + timeDiff.get(markId), 'totalDuration': value.totalDuration, 'actionAttrs': [] };\r\n            if (tmpObj.startTime < that.animationStartTime) {\r\n                that.animationStartTime = tmpObj.startTime;\r\n            }\r\n            if (tmpObj.startTime + tmpObj.totalDuration > that.animationEndTime) {\r\n                that.animationEndTime = tmpObj.startTime + tmpObj.totalDuration;\r\n            }\r\n            for (let i = 0, a; i < processedActions.length | (a = processedActions[i]); i++) {\r\n                let tmpActionSpec = new ActionSpec();\r\n                let keys = Object.keys(a);\r\n                for (let j = 0, attr; j < keys.length | (attr = keys[j]); j++) {\r\n                    tmpActionSpec[attr] = a[attr];\r\n                    if (attr === '_duration' && typeof a[attr] === 'object') {\r\n                        let datum = that.domMarks.get(markId)['data-datum'];\r\n                        let minAttrValue = minValueEachAttr.get(a[attr].field);\r\n                        tmpActionSpec[attr] = a[attr].minDuration * parseFloat(datum[a[attr].field]) / minAttrValue;\r\n                    } else if (attr === 'offsetStart') {\r\n                        tmpActionSpec[attr] = a[attr].get(markId);\r\n                    }\r\n                }\r\n                tmpObj.actionAttrs.push(tmpActionSpec);\r\n            }\r\n\r\n            markAni.set(markId, tmpObj);\r\n        })\r\n\r\n        markAni.forEach(function (value, markId) {\r\n            //update the start time of actions \r\n            for (let i = 0; i < value.actionAttrs.length; i++) {\r\n                value.actionAttrs[i].startTime = value.startTime + value.actionAttrs[i].offsetStart;//absolute start time\r\n            }\r\n\r\n            if (typeof Animation.allMarkAni.get(markId) === 'undefined') {\r\n                Animation.allMarkAni.set(markId, value);\r\n            } else {//merge animation specs for the same mark\r\n                let currentStartTime = Animation.allMarkAni.get(markId).startTime;\r\n                let currentEndTime = currentStartTime + Animation.allMarkAni.get(markId).totalDuration;\r\n                Animation.allMarkAni.get(markId).startTime = currentStartTime < value.startTime ? currentStartTime : value.startTime;\r\n                let tmpEndTime = value.startTime + value.totalDuration;\r\n                currentEndTime = currentEndTime > tmpEndTime ? currentEndTime : tmpEndTime;\r\n                Animation.allMarkAni.get(markId).totalDuration = currentEndTime - Animation.allMarkAni.get(markId).startTime;\r\n                Animation.allMarkAni.get(markId).actionAttrs = [...Animation.allMarkAni.get(markId).actionAttrs, ...value.actionAttrs];\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * calculate timing for each action then render animation by slicing the action specs into frames\r\n     */\r\n    static renderAnimation() {\r\n        let that = this;\r\n        this.allMarkAni.forEach(function (value, markId) {\r\n            //record the end time of the entire animation, and record the init status of each mark\r\n            if (that.wholeEndTime < value.startTime + value.totalDuration) {\r\n                that.wholeEndTime = value.startTime + value.totalDuration;\r\n            }\r\n\r\n            //categorize the actions according to the attribute name in order to insert place holder actions\r\n            let maskActionByAttr = new Map(), markActionByAttr = new Map();\r\n            for (let i = 0, item; i < value.actionAttrs.length | (item = value.actionAttrs[i]); i++) {\r\n                if (item.type === ActionSpec.actionTargets.mark) {\r\n                    if (typeof markActionByAttr.get(item.attribute.attrName) === 'undefined') {\r\n                        markActionByAttr.set(item.attribute.attrName, [item]);\r\n                    } else {\r\n                        markActionByAttr.get(item.attribute.attrName).push(item);\r\n                    }\r\n                } else if (item.type === ActionSpec.actionTargets.mask) {\r\n                    if (typeof maskActionByAttr.get(item.attribute.attrName) === 'undefined') {\r\n                        maskActionByAttr.set(item.attribute.attrName, [item]);\r\n                    } else {\r\n                        maskActionByAttr.get(item.attribute.attrName).push(item);\r\n                    }\r\n                } else {\r\n                    console.log('we have some action with no type !!!!!');\r\n                }\r\n            }\r\n\r\n            //add extra action to fill the timeline for both mark and mask\r\n            maskActionByAttr.forEach(function (actionList, attrName) {\r\n                //put an start action\r\n                let tmpAction0 = new ActionSpec();\r\n                tmpAction0.type = ActionSpec.actionTargets.mask;\r\n                tmpAction0.chartIdx = actionList[0].chartIdx;\r\n                tmpAction0.animationType = actionList[0].animationType;\r\n                tmpAction0.startTime = 0;\r\n                tmpAction0.duration = actionList[0].startTime;\r\n                tmpAction0.attribute = {\r\n                    'attrName': actionList[0].attribute.attrName,\r\n                    'from': actionList[0].attribute.from,\r\n                    'to': actionList[0].attribute.from\r\n                }\r\n                value.actionAttrs.push(tmpAction0);\r\n                for (let i = 0; i < actionList.length; i++) {\r\n                    let tmpAction = new ActionSpec();\r\n                    tmpAction.type = ActionSpec.actionTargets.mask;\r\n                    tmpAction.chartIdx = actionList[i].chartIdx;\r\n                    tmpAction.animationType = actionList[i].animationType;\r\n                    tmpAction.startTime = actionList[i].startTime + actionList[i].duration;\r\n                    if (i === actionList.length - 1) {\r\n                        tmpAction.duration = 'wholeEnd';\r\n                    } else {\r\n                        tmpAction.duration = actionList[i + 1].startTime - actionList[i].startTime - actionList[i].duration;\r\n                    }\r\n\r\n                    tmpAction.attribute = {\r\n                        'attrName': actionList[i].attribute.attrName,\r\n                        'from': actionList[i].attribute.to,\r\n                        'to': actionList[i].attribute.to\r\n                    }\r\n                    value.actionAttrs.push(tmpAction);\r\n                }\r\n            })\r\n            markActionByAttr.forEach(function (actionList, attrName) {\r\n                //put an start action\r\n                let tmpAction0 = new ActionSpec();\r\n                tmpAction0.type = ActionSpec.actionTargets.mark;\r\n                tmpAction0.animationType = actionList[0].animationType;\r\n                tmpAction0.startTime = 0;\r\n                tmpAction0.duration = actionList[0].startTime;\r\n                tmpAction0.attribute = {\r\n                    'attrName': actionList[0].attribute.attrName,\r\n                    'from': actionList[0].attribute.from,\r\n                    'to': actionList[0].attribute.from\r\n                }\r\n                value.actionAttrs.push(tmpAction0);\r\n                for (let i = 0; i < actionList.length; i++) {\r\n                    let tmpAction = new ActionSpec();\r\n                    tmpAction.type = ActionSpec.actionTargets.mark;\r\n                    tmpAction.animationType = actionList[i].animationType;\r\n                    tmpAction.startTime = actionList[i].startTime + actionList[i].duration;\r\n                    if (i === actionList.length - 1) {\r\n                        tmpAction.duration = 'wholeEnd';\r\n                    } else {\r\n                        tmpAction.duration = actionList[i + 1].startTime - actionList[i].startTime - actionList[i].duration;\r\n                    }\r\n\r\n                    tmpAction.attribute = {\r\n                        'attrName': actionList[i].attribute.attrName,\r\n                        'from': actionList[i].attribute.to,\r\n                        'to': actionList[i].attribute.to\r\n                    }\r\n                    value.actionAttrs.push(tmpAction);\r\n                }\r\n            })\r\n        })\r\n        console.log('The duration of the generated animation is: ' + this.wholeEndTime + 'ms');\r\n\r\n        //replace the 'wholeEnd' place holder in duration\r\n        this.allMarkAni.forEach(function (value, a) {\r\n            for (let i = 0, item; i < value.actionAttrs.length | (item = value.actionAttrs[i]); i++) {\r\n                if (item.duration === 'wholeEnd') {\r\n                    item.duration = that.wholeEndTime - item.startTime;\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    static renderFrame(timePoint) {\r\n        let frame = [];//store the visual status of each mark at this time\r\n        this.allMarkAni.forEach(function (value, markId) {\r\n            let currentStatus = new Map();\r\n            for (let i = 0, a; i < value.actionAttrs.length | (a = value.actionAttrs[i]); i++) {\r\n                if (a.attribute.from === a.attribute.to && a.duration === 0) {//nothing happends in this actionspec, skip it\r\n                    continue;\r\n                }\r\n                let resultValue = Animation.calAttrValue(a, markId, timePoint), lastValue = timePoint >= 0 ? Animation.calAttrValue(a, markId, timePoint - 1) : '';\r\n                if (resultValue !== lastValue) {\r\n                    if (a.startTime <= timePoint && a.startTime + a.duration >= timePoint) {//during this action\r\n                        currentStatus.set(a.attribute.attrName, { 'type': a.type, 'animationType': a.animationType, 'endTime': a.startTime + a.duration, 'attrName': a.attribute.attrName, 'value': resultValue });\r\n                    } else if (a.startTime + a.duration < timePoint) {\r\n                        if (typeof currentStatus.get(a.attribute.attrName) !== 'undefined') {\r\n                            if (currentStatus.get(a.attribute.attrName).endTime < a.startTime + a.duration) {\r\n                                currentStatus.set(a.attribute.attrName, { 'type': a.type, 'animationType': a.animationType, 'endTime': a.startTime + a.duration, 'attrName': a.attribute.attrName, 'value': resultValue });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (currentStatus.size > 0) {\r\n                frame.push([markId, currentStatus]);\r\n            }\r\n        })\r\n        return frame;\r\n    }\r\n\r\n    static calAttrValue(a, markId, timePoint) {\r\n        let resultValue, chartIdx = a.chartIdx;\r\n\r\n        if (a.startTime <= timePoint && a.startTime + a.duration >= timePoint) {//during this action\r\n            let percentage = parseFloat(timePoint - a.startTime) / parseFloat(a.duration);\r\n            let ratio = this.calRatio(percentage, a.easing);\r\n            switch (a.attribute.attrName) {\r\n                case 'fill':\r\n                case 'stroke':\r\n                    if (a.type === ActionSpec.actionTargets.mark) {\r\n                        if (Array.isArray(a.attribute.to)) {\r\n                            let fromColor;\r\n                            let toColor;\r\n                            for (let j = 0; j < a.attribute.to.length; j++) {\r\n                                if (a.attribute.to[j][0] === markId && typeof a.attribute.to[j][1] === 'string') {\r\n                                    fromColor = a.attribute.from[j][1];\r\n                                    toColor = a.attribute.to[j][1];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            let fromRGB = Util.color2RGB(fromColor), toRGB = Util.color2RGB(toColor);\r\n                            let valueR = parseInt((toRGB[0] - fromRGB[0]) * ratio) + fromRGB[0];\r\n                            let valueG = parseInt((toRGB[1] - fromRGB[1]) * ratio) + fromRGB[1];\r\n                            let valueB = parseInt((toRGB[2] - fromRGB[2]) * ratio) + fromRGB[2];\r\n                            resultValue = 'rgb(' + valueR + ',' + valueG + ',' + valueB + ')';\r\n                        }\r\n                    }\r\n                    break;\r\n                case 'textContent':\r\n                    if (a.type === ActionSpec.actionTargets.mark) {\r\n                        if (Array.isArray(a.attribute.to)) {\r\n                            let startValue = 0;\r\n                            for (let j = 0; j < a.attribute.to.length; j++) {\r\n                                if (a.attribute.to[j][0] === markId && (!isNaN(a.attribute.to[j][1]) || typeof a.attribute.to[j][1] === 'string')) {\r\n                                    startValue = a.attribute.to[j][1];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            resultValue = startValue;\r\n                        }\r\n                    }\r\n                    break;\r\n                case 'width':\r\n                case 'height':\r\n                case 'r':\r\n                    if (a.type === ActionSpec.actionTargets.mark) {\r\n                        if (Array.isArray(a.attribute.to)) {\r\n                            let startValue = 0;\r\n                            let finalValue = 0;\r\n                            for (let j = 0; j < a.attribute.to.length; j++) {\r\n                                if (a.attribute.to[j][0] === markId && !isNaN(a.attribute.from[j][1]) && !isNaN(a.attribute.to[j][1])) {\r\n                                    startValue = a.attribute.from[j][1];\r\n                                    finalValue = a.attribute.to[j][1];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            resultValue = startValue + (finalValue - startValue) * ratio;\r\n                        } else {\r\n                            let startValue = 0;\r\n                            let finalValue = parseFloat(this.finalStatus.get(markId)[chartIdx][a.attribute.attrName]);\r\n                            resultValue = startValue - (parseFloat(a.attribute.to - a.attribute.from) * ratio + a.attribute.from) * (startValue - finalValue);\r\n                        }\r\n                    } else {\r\n                        let startValue = parseFloat(this.minStatus.get(a.attribute.attrName));\r\n                        let finalValue = parseFloat(this.finalStatus.get(markId)[chartIdx][a.attribute.attrName]);\r\n                        if (startValue < 0) {\r\n                            resultValue = startValue + (parseFloat(a.attribute.to - a.attribute.from) * ratio + a.attribute.from) * (finalValue - startValue);\r\n                        } else {\r\n                            resultValue = (parseFloat(a.attribute.to - a.attribute.from) * ratio + a.attribute.from) * finalValue;\r\n                        }\r\n                    }\r\n                    break;\r\n                case 'y':\r\n                case 'y1':\r\n                case 'y2':\r\n                case 'cy':\r\n                    if (a.type === ActionSpec.actionTargets.mark) {\r\n                        if (Array.isArray(a.attribute.to)) {\r\n                            let startValue = 0;\r\n                            let finalValue = 0;\r\n                            for (let j = 0; j < a.attribute.to.length; j++) {\r\n                                if (a.attribute.to[j][0] === markId && !isNaN(a.attribute.from[j][1]) && !isNaN(a.attribute.to[j][1])) {\r\n                                    startValue = a.attribute.from[j][1];\r\n                                    finalValue = a.attribute.to[j][1];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            resultValue = startValue + (finalValue - startValue) * ratio;\r\n                        } else {\r\n                            let startValue = this.startY;\r\n                            let finalValue = parseFloat(this.finalStatus.get(markId)[chartIdx][a.attribute.attrName]);\r\n                            resultValue = startValue - (parseFloat(a.attribute.to - a.attribute.from) * ratio + a.attribute.from) * (startValue - finalValue);\r\n                        }\r\n                    } else if (a.type === ActionSpec.actionTargets.mask) {\r\n                        resultValue = parseFloat(this.finalStatus.get(markId)[chartIdx][a.attribute.attrName]) - 1 + (parseFloat(a.attribute.to - a.attribute.from) * ratio + a.attribute.from) * (parseFloat(this.finalStatus.get(markId)[chartIdx]['height']) + 2);\r\n                    }\r\n                    break;\r\n                case 'x':\r\n                case 'x1':\r\n                case 'x2':\r\n                case 'cx':\r\n                    if (a.type === ActionSpec.actionTargets.mark) {\r\n                        if (Array.isArray(a.attribute.to)) {//changing from one status to the other\r\n                            let startValue = 0;\r\n                            let finalValue = 0;\r\n                            for (let j = 0; j < a.attribute.to.length; j++) {\r\n                                if (a.attribute.to[j][0] === markId && !isNaN(a.attribute.from[j][1]) && !isNaN(a.attribute.to[j][1])) {\r\n                                    startValue = a.attribute.from[j][1];\r\n                                    finalValue = a.attribute.to[j][1];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            resultValue = startValue + (finalValue - startValue) * ratio;\r\n                        } else {//marks entering charts\r\n                            let startValue = this.startX;\r\n                            let finalValue = parseFloat(this.finalStatus.get(markId)[chartIdx][a.attribute.attrName]);\r\n                            resultValue = startValue + (parseFloat(a.attribute.to - a.attribute.from) * ratio + a.attribute.from) * (finalValue - startValue);\r\n                        }\r\n                    } else if (a.type === ActionSpec.actionTargets.mask) {\r\n                        resultValue = parseFloat(this.finalStatus.get(markId)[chartIdx][a.attribute.attrName]) - 1 + (parseFloat(a.attribute.to - a.attribute.from) * ratio + a.attribute.from) * (parseFloat(this.finalStatus.get(markId)[chartIdx]['width']) + 2);\r\n                    }\r\n                    break;\r\n                case 'startAngle':\r\n                    let startAngle = parseFloat(this.finalStatus.get(markId)[chartIdx].startAngle);\r\n                    let endAngle = parseFloat(this.finalStatus.get(markId)[chartIdx].endAngle);\r\n\r\n                    let _startAngle = startAngle < 0 ? startAngle + 2 * Math.PI : startAngle;\r\n                    let _endAngle = endAngle < 0 || _startAngle > endAngle ? endAngle + 2 * Math.PI : endAngle;\r\n\r\n                    let tmpAngle;\r\n                    if (_endAngle > _startAngle) {\r\n                        tmpAngle = _startAngle + (parseFloat(a.attribute.to - a.attribute.from) * ratio + a.attribute.from) * (_endAngle - _startAngle);\r\n                    } else {\r\n                        tmpAngle = _startAngle + (parseFloat(a.attribute.to - a.attribute.from) * ratio + a.attribute.from) * (Math.PI * 2 - _startAngle + _endAngle);\r\n                    }\r\n\r\n                    resultValue = {\r\n                        'cx': parseFloat(this.finalStatus.get(markId)[chartIdx]['cx']),\r\n                        'cy': parseFloat(this.finalStatus.get(markId)[chartIdx]['cy']),\r\n                        'innerRadius': parseFloat(this.finalStatus.get(markId)[chartIdx]['innerRadius']),\r\n                        'outterRadius': parseFloat(this.finalStatus.get(markId)[chartIdx]['outterRadius']) + 2,\r\n                        'startAngle': tmpAngle,\r\n                        'endAngle': parseFloat(this.finalStatus.get(markId)[chartIdx]['endAngle'])\r\n                    }\r\n                    break;\r\n                case 'innerRadius':\r\n                    let startRadius = parseFloat(this.finalStatus.get(markId)[chartIdx]['innerRadius']);\r\n                    let endRadius = parseFloat(this.finalStatus.get(markId)[chartIdx]['outterRadius']);\r\n                    let tmpRadius = (parseFloat(a.attribute.to - a.attribute.from) * ratio + a.attribute.from) * (endRadius - startRadius);\r\n                    if (tmpRadius < 0) {\r\n                        resultValue = {\r\n                            'cx': parseFloat(this.finalStatus.get(markId)[chartIdx]['cx']),\r\n                            'cy': parseFloat(this.finalStatus.get(markId)[chartIdx]['cy']),\r\n                            'innerRadius': parseFloat(this.finalStatus.get(markId)[chartIdx]['innerRadius']) + 2,\r\n                            'outterRadius': parseFloat(this.finalStatus.get(markId)[chartIdx]['outterRadius']) - tmpRadius + 2,\r\n                            'startAngle': parseFloat(this.finalStatus.get(markId)[chartIdx]['startAngle']),\r\n                            'endAngle': parseFloat(this.finalStatus.get(markId)[chartIdx]['endAngle'])\r\n                        }\r\n                    } else {\r\n                        resultValue = {\r\n                            'cx': parseFloat(this.finalStatus.get(markId)[chartIdx]['cx']),\r\n                            'cy': parseFloat(this.finalStatus.get(markId)[chartIdx]['cy']),\r\n                            'innerRadius': parseFloat(this.finalStatus.get(markId)[chartIdx]['innerRadius']) + tmpRadius + 2,\r\n                            'outterRadius': parseFloat(this.finalStatus.get(markId)[chartIdx]['outterRadius']) + 2,\r\n                            'startAngle': parseFloat(this.finalStatus.get(markId)[chartIdx]['startAngle']),\r\n                            'endAngle': parseFloat(this.finalStatus.get(markId)[chartIdx]['endAngle'])\r\n                        }\r\n                    }\r\n                    break;\r\n                case 'stroke-dashoffset':\r\n                    let startDashOffset = 0;\r\n                    let finalDashOffset = parseFloat(this.finalStatus.get(markId)[chartIdx]['stroke-dasharray']);\r\n                    resultValue = startDashOffset - (parseFloat(a.attribute.to - a.attribute.from) * ratio + a.attribute.from) * (startDashOffset - finalDashOffset);\r\n                    break;\r\n                case 'd':\r\n                    if (a.type === ActionSpec.actionTargets.mark) {\r\n                        if (Array.isArray(a.attribute.to)) {//changing from one status to the other\r\n                            let startValue = '', finalValue = '', startDiscretVal = '', finalDiscretVal = '';\r\n                            for (let j = 0; j < a.attribute.to.length; j++) {\r\n                                if (a.attribute.to[j][0] === markId && a.attribute.from[j][1] && a.attribute.to[j][1]) {\r\n                                    startValue = a.attribute.from[j][1];\r\n                                    finalValue = a.attribute.to[j][1];\r\n                                    startDiscretVal = a.attribute.from[j][2];\r\n                                    finalDiscretVal = a.attribute.to[j][2];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            resultValue = Util.calTransD(startValue, finalValue, ratio, startDiscretVal, finalDiscretVal);\r\n                        }\r\n                    }\r\n                    break;\r\n                default://numeric attribute values\r\n                    let startValue = parseFloat(this.minStatus.get(a.attribute.attrName));\r\n                    let finalValue = parseFloat(this.finalStatus.get(markId)[chartIdx][a.attribute.attrName]);\r\n                    if (startValue < 0) {\r\n                        resultValue = startValue + (parseFloat(a.attribute.to - a.attribute.from) * ratio + a.attribute.from) * (finalValue - startValue);\r\n                    } else {\r\n                        resultValue = (parseFloat(a.attribute.to - a.attribute.from) * ratio + a.attribute.from) * finalValue;\r\n                    }\r\n            }\r\n        } else if (a.startTime + a.duration < timePoint) {//past actions\r\n            switch (a.attribute.attrName) {\r\n                case 'fill':\r\n                case 'stroke':\r\n                    if (a.type === ActionSpec.actionTargets.mark) {\r\n                        if (Array.isArray(a.attribute.to)) {\r\n                            for (let j = 0; j < a.attribute.to.length; j++) {\r\n                                if (a.attribute.to[j][0] === markId && typeof a.attribute.to[j][1] === 'string') {\r\n                                    resultValue = a.attribute.to[j][1];\r\n                                    break;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            resultValue = this.finalStatus.get(markId)[chartIdx][a.attribute.attrName];\r\n                        }\r\n                    }\r\n                    break;\r\n                case 'textContent':\r\n                    if (a.type === ActionSpec.actionTargets.mark) {\r\n                        if (Array.isArray(a.attribute.to)) {\r\n                            let startValue = 0;\r\n                            for (let j = 0; j < a.attribute.to.length; j++) {\r\n                                if (a.attribute.to[j][0] === markId && (!isNaN(a.attribute.to[j][1]) || typeof a.attribute.to[j][1] === 'string')) {\r\n                                    startValue = a.attribute.to[j][1];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            resultValue = startValue;\r\n                        }\r\n                    }\r\n                    break;\r\n                case 'width':\r\n                case 'height':\r\n                case 'r':\r\n                    if (a.type === ActionSpec.actionTargets.mark) {\r\n                        if (Array.isArray(a.attribute.to)) {//changing from one status to the other\r\n                            let finalValue = 0;\r\n                            for (let j = 0; j < a.attribute.to.length; j++) {\r\n                                if (a.attribute.to[j][0] === markId) {\r\n                                    finalValue = a.attribute.to[j][1];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            resultValue = finalValue;\r\n                        } else {\r\n                            resultValue = parseFloat(this.finalStatus.get(markId)[chartIdx][a.attribute.attrName]);\r\n                        }\r\n                    } else {\r\n                        resultValue = parseFloat(this.finalStatus.get(markId)[chartIdx][a.attribute.attrName]);\r\n                    }\r\n                    break;\r\n                case 'y':\r\n                case 'y1':\r\n                case 'y2':\r\n                case 'cy':\r\n                    if (a.type === ActionSpec.actionTargets.mark) {\r\n                        if (Array.isArray(a.attribute.to)) {//changing from one status to the other\r\n                            let finalValue = 0;\r\n                            for (let j = 0; j < a.attribute.to.length; j++) {\r\n                                if (a.attribute.to[j][0] === markId) {\r\n                                    finalValue = a.attribute.to[j][1];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            resultValue = finalValue;\r\n                        } else {\r\n                            resultValue = parseFloat(this.finalStatus.get(markId)[chartIdx][a.attribute.attrName]);\r\n                        }\r\n                    } else if (a.type === ActionSpec.actionTargets.mask) {\r\n                        resultValue = parseFloat(this.finalStatus.get(markId)[chartIdx][a.attribute.attrName]) + parseFloat(this.finalStatus.get(markId)[chartIdx]['height']);\r\n                    }\r\n                    break;\r\n                case 'x':\r\n                case 'x1':\r\n                case 'x2':\r\n                case 'cx':\r\n                    if (a.type === ActionSpec.actionTargets.mark) {\r\n                        if (Array.isArray(a.attribute.to)) {//changing from one status to the other\r\n                            let finalValue = 0;\r\n                            for (let j = 0; j < a.attribute.to.length; j++) {\r\n                                if (a.attribute.to[j][0] === markId) {\r\n                                    finalValue = a.attribute.to[j][1];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            resultValue = finalValue;\r\n                        } else {\r\n                            resultValue = parseFloat(this.finalStatus.get(markId)[chartIdx][a.attribute.attrName]);\r\n                        }\r\n                    } else if (a.type === ActionSpec.actionTargets.mask) {\r\n                        resultValue = parseFloat(this.finalStatus.get(markId)[chartIdx][a.attribute.attrName]) + parseFloat(this.finalStatus.get(markId)[chartIdx]['height']);\r\n                    }\r\n                    break;\r\n                case 'startAngle':\r\n                case 'innerRadius':\r\n                    resultValue = {\r\n                        'cx': parseFloat(this.finalStatus.get(markId)[chartIdx]['cx']),\r\n                        'cy': parseFloat(this.finalStatus.get(markId)[chartIdx]['cy']),\r\n                        'innerRadius': parseFloat(this.finalStatus.get(markId)[chartIdx]['innerRadius']),\r\n                        'outterRadius': parseFloat(this.finalStatus.get(markId)[chartIdx]['outterRadius']),\r\n                        'startAngle': parseFloat(this.finalStatus.get(markId)[chartIdx]['startAngle']),\r\n                        'endAngle': parseFloat(this.finalStatus.get(markId)[chartIdx]['endAngle'])\r\n                    }\r\n                    break;\r\n                default://numeric attribute values\r\n                    resultValue = parseFloat(this.finalStatus.get(markId)[chartIdx][a.attribute.attrName]);\r\n            }\r\n        }\r\n        return resultValue;\r\n    }\r\n\r\n    static calRatio(percentage, easingType) {\r\n        let ratio = 0;\r\n        switch (easingType) {\r\n            case ActionSpec.easingType.easeLinear:\r\n                ratio = percentage;\r\n                break;\r\n            case ActionSpec.easingType.easeInQuad:\r\n                ratio = this.easeFuncs.easeInQuad(percentage);\r\n                break;\r\n            case ActionSpec.easingType.easeOutQuad:\r\n                ratio = this.easeFuncs.easeOutQuad(percentage);\r\n                break;\r\n            case ActionSpec.easingType.easeInOutQuad:\r\n                ratio = this.easeFuncs.easeInOutQuad(percentage);\r\n                break;\r\n            case ActionSpec.easingType.easeInCubic:\r\n                ratio = this.easeFuncs.easeInCubic(percentage);\r\n                break;\r\n            case ActionSpec.easingType.easeOutCubic:\r\n                ratio = this.easeFuncs.easeOutCubic(percentage);\r\n                break;\r\n            case ActionSpec.easingType.easeInOutCubic:\r\n                ratio = this.easeFuncs.easeInOutCubic(percentage);\r\n                break;\r\n            case ActionSpec.easingType.easeOutBounce:\r\n                ratio = this.easeFuncs.easeOutBounce(percentage);\r\n                break;\r\n\r\n        }\r\n        return ratio;\r\n    }\r\n\r\n    static resetAll() {\r\n        this.wholeEndTime = 0;\r\n        this.allMarkAni.clear();\r\n        this.minStatus.clear();\r\n        this.finalStatus.clear();\r\n        this.frames.clear();\r\n    }\r\n\r\n}\r\n\r\nAnimation.visualAttrs = ['x', 'y', 'cx', 'cy', 'innerRadius', 'outterRadius', 'startAngle', 'endAngle', 'width', 'height', 'opacity', 'fill', 'stroke', 'content', 'stroke-dasharray', 'stroke-dashoffset'];\r\nAnimation.startY = 0;//start coord of Y\r\nAnimation.startX = 0;//start coord of X\r\nAnimation.endX = 0;//end coord of X\r\nAnimation.wholeEndTime = 0;\r\nAnimation.minStatus = new Map();//record the min value of each attribute.\r\nAnimation.finalStatus = new Map();//record the final visual status of each mark, eg: key:mark1, value: {opacity: 1, height: 226}\r\nAnimation.allMarkAni = new Map();\r\nAnimation.frames = new Map();//output frames\r\nAnimation.easeFuncs = {\r\n    easeInQuad: (p) => {\r\n        return p * p;\r\n    },\r\n    easeOutQuad: (p) => {\r\n        return - p * (p - 2);\r\n    },\r\n    easeInOutQuad: (p) => {\r\n        if ((p / 2) < 1) return 1 / 2 * p * p;\r\n        return - ((--p) * (p - 2) - 1) / 2;\r\n    },\r\n    easeInCubic: (p) => {\r\n        return p * p * p;\r\n    },\r\n    easeOutCubic: (p) => {\r\n        return (p = p - 1) * p * p + 1;\r\n    },\r\n    easeInOutCubic: (p) => {\r\n        if ((p /= 0.5) < 1) return p * p * p / 2;\r\n        return ((p -= 2) * p * p + 2) / 2;\r\n    },\r\n    easeOutBounce: (p) => {\r\n        let ratio = 0;\r\n        if (p < (1 / 2.75)) {\r\n            ratio = 7.5625 * p * p;\r\n        } else if (p < (2 / 2.75)) {\r\n            ratio = 7.5625 * (p -= (1.5 / 2.75)) * p + 0.75;\r\n        } else if (p < (2.5 / 2.75)) {\r\n            ratio = 7.5625 * (p -= (2.25 / 2.75)) * p + 0.9375;\r\n        } else {\r\n            ratio = 7.5625 * (p -= (2.625 / 2.75)) * p + 0.984375;\r\n        }\r\n        return ratio;\r\n    }\r\n}\r\n\r\nexport default Animation;","import Util from \"./util/Util\";\r\nimport FacetSpec from \"./FacetSpec\";\r\n\r\nclass ChartSpec {\r\n    constructor(id, source) {\r\n        this.id = id;\r\n        this.source = source;\r\n    }\r\n\r\n    static loadCharts(chartSpecs, facet) {\r\n        let nameCharts = new Map();\r\n        ChartSpec.charts = [];\r\n        let nullCharts = [];\r\n        for (let i = 0; i < chartSpecs.length; i++) {\r\n            let xhr = new XMLHttpRequest(),\r\n                okStatus = document.location.protocol === \"file:\" ? 0 : 200,\r\n                svgContent;\r\n            xhr.open('GET', chartSpecs[i].source, false);\r\n            xhr.overrideMimeType(\"text/html;charset=utf-8\");\r\n            xhr.send(null);\r\n            if (xhr.status === okStatus) {\r\n                let tmpDiv = document.createElement('div');\r\n                tmpDiv.innerHTML = xhr.responseText;\r\n                svgContent = tmpDiv.children[0];\r\n                ChartSpec.charts.push(svgContent);\r\n                nameCharts.set(chartSpecs[i].id, ChartSpec.charts.length - 1);\r\n            } else if (xhr.status === 404) {\r\n                nullCharts.unshift(i);\r\n                console.log('can not find ' + chartSpecs[i].source + ' ! Please check the url.');\r\n            }\r\n        }\r\n\r\n        //remove the empty charts \r\n        for (let i = 0; i < nullCharts.length; i++) {\r\n            chartSpecs.slice(nullCharts[i], 1);\r\n        }\r\n\r\n        //generate chart facets\r\n        if (typeof facet !== 'undefined') {\r\n            ChartSpec.facetViews(nameCharts, facet);\r\n        }\r\n    }\r\n\r\n    static removeTransAndMerge() {\r\n        for (let i = 0; i < ChartSpec.charts.length; i++) {\r\n            ChartSpec.charts[i].setAttribute('trans', '0,0');\r\n            ChartSpec.removeTransitions(ChartSpec.charts[i].children[0]);\r\n        }\r\n        let resultChart = ChartSpec.mergeCharts();\r\n\r\n        return resultChart;\r\n    }\r\n\r\n    static facetViews(nameCharts, facet) {\r\n        if (facet.views.length > 0) {\r\n            let chartsToCombine = [];\r\n            for (let i = 0; i < facet.views[0].length; i++) {\r\n                let tmpRecorder = [];\r\n                for (let j = 0; j < facet.views.length; j++) {\r\n                    let chartName = facet.views[j][i];\r\n                    if (typeof nameCharts.get(chartName) !== 'undefined') {\r\n                        tmpRecorder.push(ChartSpec.charts[nameCharts.get(chartName)].cloneNode(true));\r\n                    } else {\r\n                        console.log('chart name ' + chartName + ' is undefined !');\r\n                    }\r\n                }\r\n                if (tmpRecorder.length === facet.views.length) {\r\n                    chartsToCombine.push(tmpRecorder);\r\n                }\r\n            }\r\n            ChartSpec.combineCharts(facet.type, facet.views.length, chartsToCombine);\r\n        }\r\n    }\r\n\r\n    static combineCharts(facetType, facetNum, chartsToCombine) {\r\n        let resultCharts = [];\r\n        let chartMargin = 20;\r\n        for (let i = 0; i < chartsToCombine.length; i++) {\r\n            let tmpCharts = chartsToCombine[i];\r\n            let oriWidth = parseFloat(tmpCharts[0].getAttribute('width'));\r\n            let oriHeight = parseFloat(tmpCharts[0].getAttribute('height'));\r\n            let viewBoxNums = tmpCharts[0].getAttribute('viewBox').split(' ');\r\n            let viewBoxW = parseFloat(viewBoxNums[2]);\r\n            let viewBoxH = parseFloat(viewBoxNums[3]);\r\n\r\n            let chartTransForm = Util.getTransformAttrs(tmpCharts[0].children[0]);\r\n            tmpCharts[0].children[0].setAttribute('transform', 'translate(' + chartTransForm.transNums[0] + ',' + chartTransForm.transNums[1] + ') ' + 'scale(' + chartTransForm.scaleNum / facetNum + ')');\r\n            switch (facetType) {\r\n                case FacetSpec.facetType.row:\r\n                    tmpCharts[0].setAttribute('height', oriHeight + chartMargin * tmpCharts.length);\r\n                    tmpCharts[0].setAttribute('viewBox', '0 0 ' + viewBoxW + ' ' + (viewBoxH + chartMargin * tmpCharts.length));\r\n                    break;\r\n                case FacetSpec.facetType.col:\r\n                    tmpCharts[0].setAttribute('width', oriWidth + chartMargin * tmpCharts.length);\r\n                    tmpCharts[0].setAttribute('viewBox', '0 0 ' + (viewBoxW + chartMargin * tmpCharts.length) + ' ' + viewBoxH);\r\n                    break;\r\n            }\r\n\r\n            for (let j = 0; j < tmpCharts.length; j++) {\r\n                let tmpChart = tmpCharts[j];\r\n                let tmpMarks = tmpChart.querySelectorAll('.mark');\r\n                [].forEach.call(tmpMarks, (m) => {\r\n                    let idNum = parseInt(m.getAttribute('id').substring(4));\r\n                    m.setAttribute('id', 'mark' + (idNum + j * 100000));\r\n                    m.classList.add('facet' + j);\r\n                })\r\n                if (j > 0) {//put the marks in the following charts to the 1st chart\r\n                    let chartContentG = tmpChart.children[0];\r\n                    let chartChildren = chartContentG.children;\r\n                    for (let m = 0; m < chartChildren.length; m++) {\r\n                        let tmpDom = chartChildren[m];\r\n                        let transformAttrs = Util.getTransformAttrs(tmpDom);\r\n                        switch (facetType) {\r\n                            case FacetSpec.facetType.row:\r\n                                tmpDom.setAttribute('transform', 'translate(' + transformAttrs.transNums[0] + ',' + (transformAttrs.transNums[1] + (viewBoxH + chartMargin) * j) + ') ' + 'scale(' + transformAttrs.scaleNum + ')');\r\n                                break;\r\n                            case FacetSpec.facetType.col:\r\n                                tmpDom.setAttribute('transform', 'translate(' + (transformAttrs.transNums[0] + (viewBoxW + chartMargin) * j) + ',' + transformAttrs.transNums[1] + ') ' + 'scale(' + transformAttrs.scaleNum + ')');\r\n                                break;\r\n                        }\r\n                        tmpCharts[0].children[0].appendChild(tmpDom);\r\n                    }\r\n                }\r\n            }\r\n            resultCharts.push(tmpCharts[0]);\r\n        }\r\n        ChartSpec.charts = resultCharts;\r\n    }\r\n\r\n    static mergeCharts() {\r\n        let allMarks = new Set();\r\n        let markStatus = new Map();\r\n        let markTempletes = new Map();\r\n        let attrNames = ['x', 'y', 'cx', 'cy', 'x1', 'y1', 'x2', 'y2', 'd', 'r', 'width', 'height', 'textContent', 'fill', 'stroke'];\r\n        let nullStatus = {};\r\n        for (let j = 0; j < attrNames.length; j++) {\r\n            nullStatus[attrNames[j]] = null;\r\n        }\r\n        for (let i = 0; i < ChartSpec.charts.length; i++) {\r\n            let tmpChart = ChartSpec.charts[i];\r\n            let marks = tmpChart.querySelectorAll('.mark');\r\n            if (marks.length > 0) {\r\n                [].forEach.call(marks, (m) => {\r\n                    let markId = m.getAttribute('id');\r\n                    allMarks.add(markId);\r\n                    let statusObj = {};//status of one mark in chart i\r\n                    for (let j = 0; j < attrNames.length; j++) {\r\n                        if (attrNames[j] === 'textContent') {\r\n                            statusObj[attrNames[j]] = m.innerHTML;\r\n                        } else {\r\n                            statusObj[attrNames[j]] = m.getAttribute(attrNames[j]);\r\n                        }\r\n                    }\r\n                    if (typeof markStatus.get(markId) === 'undefined') {\r\n                        markStatus.set(markId, new Array(ChartSpec.charts.length).fill(nullStatus));\r\n                    }\r\n\r\n                    markStatus.get(markId)[i] = statusObj;\r\n                    markTempletes.set(markId, m.outerHTML);\r\n                })\r\n            }\r\n        }\r\n\r\n        //find the changed attributes\r\n        ChartSpec.changedAttrs = [];\r\n        let attrNamesCopy = Util.deepClone(attrNames);\r\n        markStatus.forEach(function (statusArr, markId) {\r\n            for (let i = 0; i < attrNamesCopy.length; i++) {\r\n                let flag = true;\r\n                let compareStatus;\r\n                for (let j = 0; j < statusArr.length; j++) {\r\n                    if (typeof statusArr[j] !== 'undefined') {\r\n                        compareStatus = statusArr[j];\r\n                        break;\r\n                    }\r\n                }\r\n                for (let j = 0; j < statusArr.length; j++) {\r\n                    if (typeof statusArr[j] !== 'undefined') {\r\n                        if (statusArr[j][attrNamesCopy[i]] !== compareStatus[attrNamesCopy[i]]) {\r\n                            ChartSpec.changedAttrs.push(attrNamesCopy[i]);\r\n                            flag = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (!flag) {\r\n                    attrNamesCopy.splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n        })\r\n\r\n        //find different cmds if there is d in changedAttrs\r\n        let diffCmds = new Map();//key:cmd name, value: {cmdIdx, diffAttrIdxs}\r\n        if (ChartSpec.changedAttrs.indexOf('d') >= 0) {\r\n            diffCmds = Util.findDiffCmds(markStatus);\r\n        }\r\n\r\n        //add missing marks to each chart\r\n        allMarks = Array.from(allMarks);\r\n        ChartSpec.markDoms.clear();\r\n        for (let i = 0; i < ChartSpec.charts.length; i++) {\r\n            for (let j = 0; j < allMarks.length; j++) {\r\n                if (ChartSpec.charts[i].querySelectorAll('#' + allMarks[j]).length === 0) {//chart i does not have mark j\r\n                    let markStr = markTempletes.get(allMarks[j]);\r\n                    let tmpDiv = document.createElement('div');\r\n                    tmpDiv.innerHTML = markStr;\r\n                    let mark = tmpDiv.children[0];\r\n                    let statusObj = {};\r\n                    //set the changed attributes to the init state\r\n                    for (let a = 0; a < ChartSpec.changedAttrs.length; a++) {\r\n                        if (ChartSpec.changedAttrs[a] === 'y' && ChartSpec.changedAttrs.indexOf('height') >= 0) {\r\n                            let targetValue = parseFloat(mark.getAttribute('y')) + parseFloat(mark.getAttribute('height'));\r\n                            mark.setAttribute('y', targetValue);\r\n                            statusObj.y = targetValue;\r\n                        } else if (ChartSpec.changedAttrs[a] === 'd') {\r\n                            let resultD;\r\n                            if (mark.getAttribute('d')) {\r\n                                resultD = Util.setPathDValue(mark.getAttribute('d'), true, 0, 0, diffCmds);\r\n                            }\r\n                            mark.setAttribute('d', resultD);\r\n                            statusObj.d = resultD;\r\n                        } else if (ChartSpec.changedAttrs[a] === 'textContent') {\r\n                            mark.innerHTML = '';\r\n                            statusObj.textContent = '';\r\n                        } else if (ChartSpec.changedAttrs[a] === 'fill' || ChartSpec.changedAttrs[a] === 'stroke') {\r\n                            if (typeof mark.getAttribute(ChartSpec.changedAttrs[a]) === 'undefined') {\r\n                                mark.setAttribute(ChartSpec.changedAttrs[a], '#FFFFFF');\r\n                            }\r\n                            statusObj[ChartSpec.changedAttrs[a]] = mark.getAttribute(ChartSpec.changedAttrs[a]);\r\n                        } else {\r\n                            if (['x', 'y', 'cx', 'cy', 'x1', 'y1', 'x2', 'y2'].includes(ChartSpec.changedAttrs[a])) {\r\n                                if (ChartSpec.changedAttrs[a] === 'x2') {\r\n                                    mark.setAttribute('x2', parseFloat(mark.getAttribute('x1')));\r\n                                    statusObj['x2'] = parseFloat(mark.getAttribute('x1'));\r\n                                } else if (ChartSpec.changedAttrs[a] === 'y2') {\r\n                                    mark.setAttribute('y2', parseFloat(mark.getAttribute('y1')));\r\n                                    statusObj['y2'] = parseFloat(mark.getAttribute('y1'));\r\n                                } else {\r\n                                    statusObj[ChartSpec.changedAttrs[a]] = parseFloat(mark.getAttribute(ChartSpec.changedAttrs[a]));\r\n                                }\r\n                            } else {\r\n                                mark.setAttribute(ChartSpec.changedAttrs[a], 0);\r\n                                statusObj[ChartSpec.changedAttrs[a]] = 0;\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                    markStr = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"500\" height=\"500\">' + mark.outerHTML + '</svg>';\r\n                    let parser = new DOMParser();\r\n                    let svgMark = parser.parseFromString(markStr, \"image/svg+xml\").lastChild.children[0];\r\n                    ChartSpec.charts[i].querySelector('#chartContent').appendChild(svgMark);\r\n                    markStatus.get(allMarks[j])[i] = statusObj;\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        //set data-trans of chart 0\r\n        ChartSpec.dataTrans = new Map();\r\n        for (let j = 0; j < allMarks.length; j++) {\r\n            let statusArr = markStatus.get(allMarks[j]);\r\n            let dataTransArr = [];\r\n           \r\n            for (let si = 0; si < statusArr.length; si++) {\r\n                let tmpStatus = {};\r\n                for (let a = 0; a < ChartSpec.changedAttrs.length; a++) {\r\n                    tmpStatus[ChartSpec.changedAttrs[a]] = statusArr[si][ChartSpec.changedAttrs[a]];\r\n                }\r\n                dataTransArr.push(tmpStatus);//mark status in charts\r\n            }\r\n            //copy the status of the 1st chart as the init status\r\n            ChartSpec.dataTrans.set(allMarks[j], dataTransArr);\r\n            ChartSpec.charts[0].querySelector('#' + allMarks[j]).setAttribute('data-transition', JSON.stringify({ \"dataTrans\": dataTransArr }, null, '\\t'))\r\n        }\r\n\r\n        return ChartSpec.charts[0];\r\n    }\r\n\r\n    static getBBoxes() {\r\n        let svg = document.getElementById('chartContainer').children[0];\r\n        let marks = svg.querySelectorAll('[id^=\"mark\"]');\r\n        let bBoxes = new Map();\r\n        if (marks.length > 0) {\r\n            [].forEach.call(marks, (m) => {\r\n                let markId = m.getAttribute('id');\r\n                let bBox;\r\n                if (m.tagName === 'text') {\r\n                    bBox = m.getBBox();\r\n                    bBox.width += 10;\r\n                } else {\r\n                    bBox = m.getBBox();\r\n                }\r\n                bBoxes.set(markId, bBox);\r\n            })\r\n        }\r\n        return bBoxes;\r\n    }\r\n\r\n    static removeTransitions(t) {\r\n        let tr = t.getAttribute('transform');\r\n        let parentTrans = t.parentNode.getAttribute('trans').split(',');\r\n        if (tr) {\r\n            tr = tr.replace(/translate|scale|rotate|\\s/g, (m) => {\r\n                return m === ' ' ? '' : '@' + m;\r\n            });\r\n            tr = tr.replace(/(^@*)|(@*$)/g, '').split('@');\r\n            let scaleStr = '', transStr = '';\r\n            for (let i = 0; i < tr.length; i++) {\r\n                if (tr[i].indexOf('translate') >= 0) {\r\n                    transStr = tr[i];\r\n                } else if (tr[i].indexOf('scale') >= 0) {\r\n                    scaleStr = tr[i];\r\n                }\r\n            }\r\n            let transPosiStr = transStr.replace(/translate\\(| |\\)/g, '').split(',');\r\n            t.setAttribute('transform', scaleStr);\r\n            if (t.tagName === 'g') {\r\n                t.setAttribute('trans', (parseFloat(transPosiStr[0]) + parseFloat(parentTrans[0])) + ',' + (parseFloat(transPosiStr[1]) + parseFloat(parentTrans[1])));\r\n            } else {\r\n                Util.transShape(t, parseFloat(transPosiStr[0]) + parseFloat(parentTrans[0]), parseFloat(transPosiStr[1]) + parseFloat(parentTrans[1]));\r\n            }\r\n        } else {\r\n            if (t.tagName === 'g') {\r\n                t.setAttribute('trans', parentTrans.join(','));\r\n            } else {\r\n                Util.transShape(t, parseFloat(parentTrans[0]), parseFloat(parentTrans[1]));\r\n            }\r\n        }\r\n        if (t.children.length > 0) {\r\n            for (let i = 0; i < t.children.length; i++) {\r\n                ChartSpec.removeTransitions(t.children[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    static getMarkBBox(svg) {\r\n        let markBoundingRects = new Map();\r\n        let marks = svg.querySelectorAll('[id^=\"mark\"]');\r\n        if (marks.length > 0) {\r\n            [].forEach.call(marks, function (m) {\r\n                if (m.tagName !== 'text') {\r\n                    markBoundingRects.set(m.getAttribute('id'), m.getBBox());\r\n                } else {//text tag, the bounding box coords is the bottom left corner\r\n                    let bBox = m.getBBox();\r\n                    bBox.y -= bBox.height;\r\n                    bBox.width += 10;\r\n                    markBoundingRects.set(m.getAttribute('id'), bBox);\r\n                }\r\n            });\r\n        }\r\n        return markBoundingRects;\r\n    }\r\n\r\n    static processAnimateChart(chartStr, bBoxes) {\r\n        let tmpDiv = document.createElement('div');\r\n        tmpDiv.innerHTML = chartStr;\r\n        let aniSvg = tmpDiv.children[0];\r\n\r\n        aniSvg.setAttribute('id', 'visAnimation');\r\n        aniSvg.querySelector('#chartContent').setAttribute('id', 'aniChartContent');\r\n        let aniMarks = aniSvg.querySelectorAll('[id^=\"mark\"]');\r\n        if (aniMarks.length > 0) {\r\n            [].forEach.call(aniMarks, function (am) {\r\n                let markId = am.getAttribute('id');\r\n                let idIndex = markId.substring(4);\r\n                am.setAttribute('id', 'ani' + markId);\r\n\r\n                //create corresponding mask\r\n                let mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask');\r\n                mask.setAttributeNS(null, 'id', 'animaskmark' + idIndex);\r\n                let rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n                rect.setAttributeNS(null, 'id', 'animaskBgmark' + idIndex);\r\n                rect.setAttributeNS(null, 'x', bBoxes.get(markId).x - 1);\r\n                rect.setAttributeNS(null, 'y', bBoxes.get(markId).y - 1);\r\n                rect.setAttributeNS(null, 'width', bBoxes.get(markId).width + 2);\r\n                rect.setAttributeNS(null, 'height', bBoxes.get(markId).height + 2);\r\n                rect.setAttributeNS(null, 'fill', '#fff');\r\n                mask.appendChild(rect);\r\n\r\n                let rect2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n                rect2.setAttributeNS(null, 'x', -10000);\r\n                rect2.setAttributeNS(null, 'y', -10000);\r\n                rect2.setAttributeNS(null, 'width', 20000);\r\n                rect2.setAttributeNS(null, 'height', 20000);\r\n                rect2.setAttributeNS(null, 'fill', '#fff');\r\n                mask.appendChild(rect2);\r\n\r\n                aniSvg.appendChild(mask);\r\n                am.setAttribute('mask', 'url(#animaskmark' + idIndex + ')');\r\n            });\r\n        }\r\n        return aniSvg;\r\n    }\r\n}\r\n\r\nChartSpec.charts = [];\r\nChartSpec.changedAttrs = [];\r\nChartSpec.dataTrans = new Map();\r\nChartSpec.markDoms = new Map();\r\n\r\nexport default ChartSpec;","class FacetSpec {\r\n    constructor(type, views) {\r\n        this._type;\r\n        this._views;\r\n        this.views = views;\r\n        this.type = type;\r\n    }\r\n\r\n    set type(type) {\r\n        if (typeof type !== 'undefined') {\r\n            if (Object.keys(FacetSpec.facetType).includes(type)) {\r\n                this._type = type;\r\n            } else {\r\n                console.log('the facet type has to be one of \"row\" or \"column\", setting to default value \"column\".')\r\n                this._type = FacetSpec.facetType.col;\r\n            }\r\n        }\r\n    }\r\n\r\n    get type() {\r\n        return this._type;\r\n    }\r\n\r\n    set views(views) {\r\n        if (typeof views !== 'undefined') {\r\n            //find the max number of charts in views\r\n            let maxLen = 0;\r\n            for (let i = 0; i < views.length; i++) {\r\n                if (views[i].length > maxLen) {\r\n                    maxLen = views[i].length;\r\n                }\r\n            }\r\n            for (let i = 0; i < views.length; i++) {\r\n                if (views[i].length < maxLen) {\r\n                    let lastItem = views[i][views[i].length - 1];\r\n                    let numDiff = maxLen - views[i].length;\r\n                    while (numDiff > 0) {\r\n                        views[i].push(lastItem);\r\n                        numDiff--;\r\n                    }\r\n                }\r\n            }\r\n            this._views = views;\r\n        }\r\n    }\r\n\r\n    get views() {\r\n        return this._views;\r\n    }\r\n}\r\n\r\nFacetSpec.facetType = {\r\n    row: 'row',\r\n    col: 'column'\r\n}\r\n\r\nexport default FacetSpec;","let TimingSpec = require('./TimingSpec.js');\r\nlet Animation = require('./Animation.js');\r\nlet AniChart = require('./AniChart.js');\r\nlet Renderer = require('./Renderer.js');\r\n\r\nwindow.aniChart = {\r\n    frameRate: TimingSpec.FRAME_RATE,\r\n    duration: () => {\r\n        return Animation.wholeEndTime;\r\n    },\r\n    loadSpec: (url, callback) => {\r\n        AniChart.loadSpec(url, callback);\r\n    },\r\n    renderSpec: (spec) => {\r\n        let aniChartObj = new AniChart();\r\n        aniChartObj.init(spec);\r\n        aniChartObj.render();\r\n    },\r\n    play: () => {\r\n        Renderer.play();\r\n    },\r\n    renderFrame: (time) => {//render frame of a specific timepoint\r\n        return Renderer.renderFrame(time);\r\n    },\r\n    reset: function () {\r\n        Renderer.resetCover();\r\n        Animation.resetAll();\r\n    },\r\n    test: function(spec) {\r\n        console.log('this is a test! ', spec);\r\n    }\r\n}","import TimingSpec from './TimingSpec.js';\r\n\r\nclass ActionSpec extends TimingSpec {\r\n    constructor() {\r\n        super();\r\n        this.chartIdx = 0;\r\n        this._type = ActionSpec.actionTypes.appear;\r\n        this.animationType = '';//not set by the user\r\n        this._easing = ActionSpec.easingType.easeLinear;\r\n        this._duration = 0;\r\n        this.startTime;//not set by the user\r\n        this.attribute = class {\r\n            constructor() {\r\n                this.attrName;\r\n                this.from;\r\n                this.to;\r\n            }\r\n        }\r\n    }\r\n\r\n    /***** getters and setters *****/\r\n    set type(tp) {\r\n        if (typeof tp !== 'undefined') {\r\n            if (Object.keys(ActionSpec.actionTypes).includes(tp)) {\r\n                this._type = tp;\r\n            } else {\r\n                alert('the \\'type\\' of action is not defined. ')\r\n            }\r\n        }\r\n    }\r\n\r\n    get type() {\r\n        return this._type;\r\n    }\r\n\r\n    set easing(es) {\r\n        if (typeof es !== 'undefined') {\r\n            if (Object.keys(ActionSpec.easingType).includes(es)) {\r\n                this._easing = es;\r\n            } else {\r\n                alert('the \\'easing\\' of action is not defined. ')\r\n            }\r\n        }\r\n    }\r\n\r\n    get easing() {\r\n        return this._easing;\r\n    }\r\n\r\n    set duration(drtn) {\r\n        if (typeof drtn !== 'undefined') {\r\n            if (typeof drtn === 'number') {\r\n                this._duration = Math.floor(drtn / (1000 / TimingSpec.FRAME_RATE)) * (1000 / TimingSpec.FRAME_RATE);\r\n            } else {\r\n                this._duration = drtn;\r\n            }\r\n        }\r\n    }\r\n\r\n    get duration() {\r\n        return this._duration;\r\n    }\r\n    /***** end getters and setters *****/\r\n\r\n    /**\r\n     * init action using json obj\r\n     * @param {JSON obj} actionJson\r\n     */\r\n    initAction(actionJson) {\r\n        this.chartIdx = actionJson.chartIdx;\r\n        this.type = actionJson.type;//action type\r\n        this.animationType = actionJson.animationType;//animation type\r\n        this.reference = actionJson.reference;//timingSpec reference\r\n        this.offset = actionJson.offset;//timingSpec delay\r\n        this.duration = actionJson.duration;//action duration\r\n        this.easing = actionJson.easing;\r\n\r\n        //attributes only take effect when type is custom\r\n        if (typeof actionJson.attribute !== 'undefined') {\r\n            this.attribute.attrName = actionJson.attribute.attrName;\r\n            this.attribute.from = actionJson.attribute.from;\r\n            this.attribute.to = actionJson.attribute.to;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * translate template animations to 'custom' type with the transition on some visual attributes\r\n     */\r\n    static transToVisualAttrAction(actionJson, chartIdx, changedAttrs, dataTrans) {\r\n        let actionJsonArr = [];\r\n\r\n        //generate pre-render actions\r\n        for (let i = 0; i < changedAttrs.length; i++) {\r\n            let changedAttr = changedAttrs[i];\r\n            let fromArr = [], toArr = [];\r\n            dataTrans.forEach(function (transArr, markId) {\r\n                if (chartIdx + 1 < transArr.length) {\r\n                    if (changedAttr === 'd' || changedAttr === 'textContent' || changedAttr === 'fill' || changedAttr === 'stroke') {\r\n                        let tmpFromItem = [markId, !transArr[chartIdx][changedAttr] ? (changedAttr === 'd' ? 'm0,0' : transArr[chartIdx][changedAttr]) : transArr[chartIdx][changedAttr]],\r\n                            tmpToItem = [markId, !transArr[chartIdx + 1][changedAttr] ? (changedAttr === 'd' ? 'm0,0' : transArr[chartIdx + 1][changedAttr]) : transArr[chartIdx + 1][changedAttr]];\r\n                        if (changedAttr === 'd') {\r\n                            let tmpFromPath = document.createElementNS('http://www.w3.org/2000/svg', 'path'),\r\n                                tmpToPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n                            tmpFromPath.setAttributeNS(null, 'd', !transArr[chartIdx][changedAttr] ? 'm0,0' : transArr[chartIdx][changedAttr]);\r\n                            tmpToPath.setAttributeNS(null, 'd', !transArr[chartIdx + 1][changedAttr] ? 'm0,0' : transArr[chartIdx + 1][changedAttr]);\r\n                            let tmpFromPathLen = tmpFromPath.getTotalLength(),\r\n                                tmpToPathLen = tmpToPath.getTotalLength();\r\n                            let stepNum = 300, fromPathStepLen = tmpFromPathLen / stepNum, toPathStepLen = tmpToPathLen / stepNum;\r\n                            let fromDiscritPath = [], toDiscritPath = [];\r\n                            for (let i = 0; i < stepNum; i++) {\r\n                                let tmpFromPnt = tmpFromPath.getPointAtLength(fromPathStepLen * i),\r\n                                    tmpToPnt = tmpToPath.getPointAtLength(toPathStepLen * i);\r\n                                fromDiscritPath.push([tmpFromPnt.x, tmpFromPnt.y]);\r\n                                toDiscritPath.push([tmpToPnt.x, tmpToPnt.y]);\r\n                            }\r\n                            tmpFromItem.push(fromDiscritPath);\r\n                            tmpToItem.push(toDiscritPath);\r\n                        }\r\n                        fromArr.push(tmpFromItem);\r\n                        toArr.push(tmpToItem);\r\n                    } else {\r\n                        fromArr.push([markId, parseFloat(transArr[chartIdx][changedAttr])]);\r\n                        toArr.push([markId, parseFloat(transArr[chartIdx + 1][changedAttr])]);\r\n                    }\r\n                }\r\n            })\r\n            let preObj = {\r\n                chartIdx: actionJson.chartIdx,\r\n                reference: TimingSpec.timingRef.previousStart,\r\n                offset: 0,\r\n                duration: actionJson.type === ActionSpec.actionTypes.transition ? actionJson.duration : 0,\r\n                type: ActionSpec.actionTargets.mark,\r\n                animationType: ActionSpec.targetAnimationType.custom,\r\n                attribute: {\r\n                    attrName: changedAttr,\r\n                    from: fromArr,\r\n                    to: toArr\r\n                }\r\n            }\r\n\r\n            actionJsonArr.push(preObj);\r\n        }\r\n\r\n        if (actionJson.type !== ActionSpec.actionTypes.transition) {\r\n            let tmpObj = {\r\n                chartIdx: actionJson.chartIdx,\r\n                reference: actionJson.reference,//timingSpec offset reference\r\n                offset: actionJson.offset,\r\n                easing: actionJson.easing,\r\n                duration: typeof actionJson.duration === 'undefined' ? 300 : actionJson.duration,\r\n                type: ActionSpec.actionTargets.mask\r\n            };\r\n\r\n            switch (actionJson.type) {\r\n                case ActionSpec.actionTypes.fade:\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.fade;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'opacity',\r\n                        from: 1,\r\n                        to: 0\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.fadeOut:\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.fade;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'opacity',\r\n                        from: 0,\r\n                        to: 1\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.wipeBottom:\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.wipe;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'height',\r\n                        from: 1,\r\n                        to: 0\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.wipeOutFromTop:\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.wipe;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'height',\r\n                        from: 0,\r\n                        to: 1\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.wipeTop:\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.move;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'y',\r\n                        from: 0,\r\n                        to: 1\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.wipeOutFromBottom:\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.move;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'y',\r\n                        from: 1,\r\n                        to: 0\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.wipeLeft:\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.move;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'x',\r\n                        from: 0,\r\n                        to: 1\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.wipeOutFromRight:\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.move;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'x',\r\n                        from: 1,\r\n                        to: 0\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.wipeRight:\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.wipe;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'width',\r\n                        from: 1,\r\n                        to: 0\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.wipeOutFromLeft:\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.wipe;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'width',\r\n                        from: 0,\r\n                        to: 1\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.wheel:\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.wheel;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'startAngle',\r\n                        from: 0,\r\n                        to: 1\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.wheelOut:\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.wheel;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'startAngle',\r\n                        from: 1,\r\n                        to: 0\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.circle:\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.circle;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'innerRadius',\r\n                        from: 0,\r\n                        to: 1\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.circleOut:\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.circle;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'innerRadius',\r\n                        from: 1,\r\n                        to: 0\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.grow:\r\n                    tmpObj.type = ActionSpec.actionTargets.mark;\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.grow;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'stroke-dashoffset',\r\n                        from: 1,\r\n                        to: 0\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.degrow:\r\n                    tmpObj.type = ActionSpec.actionTargets.mark;\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.grow;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'stroke-dashoffset',\r\n                        from: 0,\r\n                        to: 1\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.appear:\r\n                    tmpObj.duration = 1000 / TimingSpec.FRAME_RATE;\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.fade;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'opacity',\r\n                        from: 1,\r\n                        to: 0\r\n                    };\r\n                    break;\r\n                case ActionSpec.actionTypes.zoom:\r\n                    tmpObj.type = ActionSpec.actionTargets.mark;\r\n                    tmpObj.reference = TimingSpec.timingRef.previousStart;\r\n                    tmpObj.offset = 0;\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.wipe;\r\n                    tmpObj.attribute = {\r\n                        attrName: 'width',\r\n                        from: 0,\r\n                        to: 1\r\n                    };\r\n\r\n                    let tmpObj2 = {\r\n                        chartIdx: actionJson.chartIdx,\r\n                        easing: actionJson.easing,\r\n                        duration: typeof actionJson.duration === 'undefined' ? 300 : actionJson.duration,\r\n                        reference: actionJson.reference,//timingSpec offset reference\r\n                        offset: actionJson.offset,\r\n                        type: ActionSpec.actionTargets.mask,\r\n                        animationType: ActionSpec.targetAnimationType.wipe,\r\n                        attribute: {\r\n                            attrName: 'height',\r\n                            from: 1,\r\n                            to: 0\r\n                        }\r\n                    };\r\n                    actionJsonArr.push(tmpObj2);\r\n\r\n                    break;\r\n                case ActionSpec.actionTypes.custom:\r\n                    tmpObj.type = ActionSpec.actionTargets.mark;\r\n                    tmpObj.animationType = ActionSpec.targetAnimationType.custom;\r\n                    tmpObj.attribute = {};\r\n                    if (typeof actionJson.attribute !== 'undefined') {\r\n                        tmpObj.attribute = {\r\n                            attrName: actionJson.attribute.attrName,\r\n                            from: actionJson.attribute.from,\r\n                            to: actionJson.attribute.to\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n            actionJsonArr.push(tmpObj);\r\n        }\r\n\r\n        return actionJsonArr;\r\n    }\r\n\r\n    /**\r\n     * calculate the total duration of all the actions\r\n     * @param {Array<ActionSpec>} actionArr \r\n     * @param {Map} durationAttrValues: key: data attr name, value Map{key: markId, value: attr value}\r\n     */\r\n    static calActionDuration(actionArr, durationAttrValues, domMarks) {\r\n        let wholeStart = 0, wholeEnd = -100000;//start time of the earliest action and end time of the lastst action\r\n        let lastStart = 0, lastEnd = 0;\r\n        let durationWithAttr = false;\r\n\r\n        for (let i = 0; i < actionArr.length; i++) {\r\n            let tmpStartMap, tmpEndMap = new Map();\r\n            tmpStartMap = actionArr[i].calOffsetTime(lastStart, lastEnd, 0, domMarks);//change to retunr value of Map\r\n\r\n            //ignore the influence of the animation for the boundary of the mask\r\n            if (i > 0) {\r\n                if (actionArr[i - 1].animationType === ActionSpec.targetAnimationType.mistake) {\r\n                    tmpStartMap.forEach(function (tmpStart, markId) {\r\n                        tmpStartMap.set(markId, tmpStart - actionArr[i - 1].offset);\r\n                    })\r\n                }\r\n            }\r\n\r\n            let minTmpStart = 1000000, maxTmpEnd = -100000;\r\n            actionArr[i].offsetStart = new Map();\r\n            tmpStartMap.forEach(function (tmpStart, markId) {\r\n                let tmpEnd = 0;\r\n                if (typeof actionArr[i].duration === 'object') {\r\n                    durationWithAttr = true;\r\n                    tmpEnd = tmpStart;\r\n                } else if (typeof actionArr[i].duration === 'number') {\r\n                    tmpEnd = tmpStart + actionArr[i].duration;\r\n                }\r\n                tmpEndMap.set(markId, tmpEnd);\r\n                actionArr[i].offsetStart.set(markId, tmpStart);\r\n\r\n                if (tmpStart < minTmpStart) {\r\n                    minTmpStart = tmpStart;\r\n                }\r\n                if (tmpEnd > maxTmpEnd) {\r\n                    maxTmpEnd = tmpEnd;\r\n                }\r\n                if (tmpStart < wholeStart) {\r\n                    wholeStart = tmpStart;\r\n                }\r\n                if (tmpEnd > wholeEnd) {\r\n                    wholeEnd = tmpEnd;\r\n                }\r\n            })\r\n\r\n            lastStart = minTmpStart;\r\n            lastEnd = maxTmpEnd;\r\n        }\r\n\r\n        let tmpResultDuration = wholeEnd - wholeStart;\r\n        let resultDurations = new Map();//key: markId, value: duraiton of this mark\r\n        let minValueEachAttr = new Map();\r\n        if (durationWithAttr) {//add duration with the attribute values\r\n            //find the min value for each attr\r\n            durationAttrValues.forEach(function (attrs, markId) {\r\n                attrs.forEach(function (attrValue, attrName) {\r\n                    if (typeof minValueEachAttr.get(attrName) === 'undefined' || attrValue[0] < minValueEachAttr.get(attrName)) {\r\n                        minValueEachAttr.set(attrName, attrValue[0]);\r\n                    }\r\n                })\r\n            })\r\n            durationAttrValues.forEach(function (attrs, markId) {\r\n                let tmpExtraDuration = 0;\r\n                attrs.forEach(function (attrValue, attrName) {\r\n                    let minAttrValue = minValueEachAttr.get(attrName);\r\n\r\n                    tmpExtraDuration += attrValue[1] * attrValue[0] / minAttrValue;\r\n                })\r\n                resultDurations.set(markId, tmpResultDuration + tmpExtraDuration);\r\n            })\r\n        } else {//directly set the duration of each mark with tmpResultDuration\r\n            durationAttrValues.forEach(function (value, markId) {\r\n                resultDurations.set(markId, tmpResultDuration);\r\n            })\r\n        }\r\n        return [resultDurations, minValueEachAttr, actionArr];\r\n    }\r\n}\r\n\r\nActionSpec.actionTypes = {\r\n    fade: 'fade',\r\n    wipeBottom: 'wipe bottom',\r\n    wipeTop: 'wipe top',\r\n    wipeLeft: 'wipe left',\r\n    wipeRight: 'wipe right',\r\n    wheel: 'wheel',\r\n    appear: 'appear',\r\n    circle: 'circle',\r\n    grow: 'grow',\r\n    custom: 'custom',\r\n    fadeOut: 'fade out',\r\n    wipeOutFromLeft: 'wipe out from left',\r\n    wipeOutFromTop: 'wipe out from top',\r\n    wipeOutFromRight: 'wipe out from right',\r\n    wipeOutFromBottom: 'wipe out from bottom',\r\n    wheelOut: 'wheel out',\r\n    circleOut: 'circle out',\r\n    degrow: 'degrow',\r\n    transition: 'magic move',\r\n    zoom: 'zoom',\r\n    mark: 'mask',\r\n    mask: 'mark'\r\n}\r\n\r\nActionSpec.actionTargets = {\r\n    mark: 'mark',\r\n    mask: 'mask'\r\n}\r\n\r\nActionSpec.targetAnimationType = {\r\n    fade: 'fade',\r\n    wipe: 'wipe',\r\n    move: 'move',\r\n    wheel: 'wheel',\r\n    circle: 'circle',\r\n    appear: 'appear',\r\n    grow: 'grow',\r\n    custom: 'custom',\r\n    mistake: 'mistake'\r\n}\r\n\r\nActionSpec.easingType = {\r\n    easeLinear: 'easeLinear',\r\n    easeInQuad: 'easeInQuad',\r\n    easeOutQuad: 'easeOutQuad',\r\n    easeInOutQuad: 'easeInOutQuad',\r\n    easeInCubic: 'easeInCubic',\r\n    easeOutCubic: 'easeOutCubic',\r\n    easeInOutCubic: 'easeInOutCubic',\r\n    easeOutBounce: 'easeOutBounce'\r\n}\r\n\r\nexport default ActionSpec;","import TimingSpec from './TimingSpec.js';\r\n\r\nclass GroupingSpec extends TimingSpec {\r\n    constructor() {\r\n        super();\r\n        this._groupBy = 'id'; //optional\r\n        this._reference = TimingSpec.timingRef.previousStart;\r\n        this._delay = 0;\r\n        this.sort = class { //optional\r\n            constructor() {\r\n                this.field;\r\n                this.order;\r\n                this.expr;\r\n            }\r\n        }\r\n\r\n        this.grouping;//optional, another GroupingSpec object indicating more groupings\r\n    }\r\n\r\n    /***** getters and setters *****/\r\n    set groupBy(gb) {\r\n        if (typeof gb !== 'undefined')\r\n            this._groupBy = gb;\r\n    }\r\n\r\n    get groupBy() {\r\n        return this._groupBy;\r\n    }\r\n\r\n    set reference(ref) {\r\n        if (typeof ref !== 'undefined') {\r\n            let tmpRefStr = TimingSpec.transRef(ref);\r\n            if (Object.keys(TimingSpec.timingRef).includes(tmpRefStr)) {\r\n                this._reference = ref;\r\n            } else {\r\n                alert('the \\'reference\\' of TimingSpec has to be one of \\'previousStart\\', \\'previousEnd\\' or \\'absolute\\'. ')\r\n            }\r\n        }\r\n    }\r\n\r\n    get reference() {\r\n        return this._reference;\r\n    }\r\n\r\n    set delay(dly) {\r\n        if (typeof dly !== 'undefined') {\r\n            if (dly >= 1000 / TimingSpec.FRAME_RATE || dly === 0) {\r\n                this._delay = dly;\r\n            } else {\r\n                this._delay = 1000 / TimingSpec.FRAME_RATE;\r\n            }\r\n        }\r\n    }\r\n\r\n    get delay() {\r\n        return this._delay;\r\n    }\r\n    /***** end getters and setters *****/\r\n\r\n    /**\r\n     * init nested grouping and actions using json obj\r\n     * @param {JSON obj} groupingJson \r\n     */\r\n    initGrouping(groupingJson) {\r\n        this.groupBy = groupingJson.groupBy;\r\n        this.reference = groupingJson.reference;\r\n        this.delay = groupingJson.delay;\r\n\r\n        if (typeof groupingJson.sort !== 'undefined') {\r\n            this.sort.field = groupingJson.sort.field;\r\n            this.sort.order = groupingJson.sort.order;\r\n            this.sort.expr = groupingJson.sort.expr;\r\n        }\r\n\r\n        if (typeof groupingJson.grouping !== 'undefined') {\r\n            this.grouping = new GroupingSpec();\r\n            this.grouping.initGrouping(groupingJson.grouping);\r\n        } else if (typeof groupingJson.grouping === 'undefined' && groupingJson.groupBy !== 'id') {\r\n            //didnot goruping to id, add extra grouping by id\r\n            this.grouping = new GroupingSpec();\r\n            this.grouping.groupBy = 'id';\r\n        }\r\n    }\r\n\r\n    arrangeOrder(markIds, domMarks) {\r\n        let root = {};\r\n        root.groupRef = 'root';\r\n        root.children = [];\r\n        root.marks = markIds;\r\n        this.generateTree(root, domMarks);\r\n\r\n        let orderedMarks = this.getMarkOrder(root);\r\n        return orderedMarks;\r\n    }\r\n    generateTree(t, domMarks) {\r\n        let groupByRef = this.groupBy;\r\n\r\n        let nodesThisLevel = new Map();\r\n        for (let i = 0, markId; i < t.marks.length | (markId = t.marks[i]); i++) {\r\n            let datum = domMarks.get(markId)['data-datum'];//datum stored in the tag\r\n            let refValue;\r\n            if (typeof domMarks.get(markId)[groupByRef] !== 'undefined') {\r\n                refValue = domMarks.get(markId)[groupByRef];\r\n            } else if (typeof domMarks.get(markId)[groupByRef] === 'undefined' && typeof datum[groupByRef] !== 'undefined') {\r\n                refValue = datum[groupByRef];\r\n            } else {\r\n                console.log('error: grouping by an unknown attribute');\r\n                return;\r\n            }\r\n\r\n            if (typeof nodesThisLevel.get(refValue) !== 'undefined') {\r\n                nodesThisLevel.get(refValue).marks.push(markId);\r\n            } else {\r\n                let tmpObj = {};\r\n                tmpObj.groupRef = groupByRef;\r\n                tmpObj.refValue = refValue;\r\n                tmpObj.children = [];\r\n                tmpObj.marks = [markId];\r\n                nodesThisLevel.set(refValue, tmpObj);\r\n            }\r\n        }\r\n\r\n        //order nodes of this level according to the 'sort' spec\r\n        switch (typeof this.sort.order) {\r\n            case 'object'://Array\r\n                for (let i = 0, refValue; i < this.sort.order.length | (refValue = this.sort.order[i]); i++) {\r\n                    if (typeof nodesThisLevel.get(refValue) !== 'undefined') {\r\n                        t.children.push(nodesThisLevel.get(refValue));\r\n                    }\r\n                }\r\n                break;\r\n            case 'string'://'ascending' | 'descending'\r\n                //check whether have come to the lowest level\r\n                let hasSingleMark = true;\r\n                nodesThisLevel.forEach(function (value, ref) {\r\n                    if (value.marks.length > 1) {\r\n                        hasSingleMark = false;\r\n                    }\r\n                })\r\n\r\n                //only take effect when a specific field is specified and are on the lowest level\r\n                if (typeof this.sort.field !== 'undefined' && hasSingleMark) {\r\n                    let orderRef = this.sort.field;\r\n                    let nodesThisLevelArr = [...nodesThisLevel];\r\n                    let orderType = this.sort.order;\r\n                    nodesThisLevelArr.sort(function (a, b) {\r\n                        let markId1 = a[1].marks[0];\r\n                        let markId2 = b[1].marks[0];\r\n                        let orderRefValue1 = '', orderRefValue2 = '';\r\n                        let datum1 = domMarks.get(markId1)['data-datum'];\r\n                        let datum2 = domMarks.get(markId2)['data-datum'];\r\n                        if (typeof domMarks.get(markId1)[orderRef] !== 'undefined' && domMarks.get(markId2)[orderRef] !== 'undefined') {\r\n                            orderRefValue1 = domMarks.get(markId1)[orderRef];\r\n                            orderRefValue2 = domMarks.get(markId2)[orderRef];\r\n                        } else if (typeof domMarks.get(markId1)[orderRef] === 'undefined'\r\n                            && typeof datum1[orderRef] !== 'undefined'\r\n                            && typeof domMarks.get(markId2)[orderRef] === 'undefined'\r\n                            && typeof datum2[orderRef] !== 'undefined') {\r\n                            orderRefValue1 = datum1[orderRef];\r\n                            orderRefValue2 = datum2[orderRef];\r\n                        }\r\n\r\n                        if (!isNaN(parseFloat(orderRefValue1))) {\r\n                            orderRefValue1 = parseFloat(orderRefValue1);\r\n                        }\r\n                        if (!isNaN(parseFloat(orderRefValue2))) {\r\n                            orderRefValue2 = parseFloat(orderRefValue2);\r\n                        }\r\n\r\n                        if (orderType === GroupingSpec.orderTypes.ascending) {\r\n                            if (orderRefValue1 >= orderRefValue2) {\r\n                                return 1;\r\n                            } else {\r\n                                return -1;\r\n                            }\r\n                        } else if (orderType === GroupingSpec.orderTypes.descending) {\r\n                            if (orderRefValue2 >= orderRefValue1) {\r\n                                return 1;\r\n                            } else {\r\n                                return -1;\r\n                            }\r\n                        } else if (orderType === GroupingSpec.orderTypes.random) {\r\n                            return Math.random() >= 0.5 ? 1 : -1;\r\n                        }\r\n\r\n                    })\r\n                    for (let i = 0, tmpNode; i < nodesThisLevelArr.length | (tmpNode = nodesThisLevelArr[i]); i++) {\r\n                        t.children.push(tmpNode[1]);\r\n                    }\r\n                } else {\r\n                    let nodesThisLevelArr = [...nodesThisLevel];\r\n                    if (this.sort.order === GroupingSpec.orderTypes.ascending) {\r\n                        nodesThisLevelArr.sort(function (a, b) {\r\n                            if (a[0] >= b[0]) {\r\n                                return 1;\r\n                            } else {\r\n                                return -1;\r\n                            }\r\n                        })\r\n                    } else if (this.sort.order === GroupingSpec.orderTypes.descending) {\r\n                        nodesThisLevelArr.sort(function (a, b) {\r\n                            if (b[0] >= a[0]) {\r\n                                return 1;\r\n                            } else {\r\n                                return -1;\r\n                            }\r\n                        })\r\n                    } else if (this.sort.order === GroupingSpec.orderTypes.random) {\r\n                        nodesThisLevelArr.sort(function (a, b) {\r\n                            return Math.random() >= 0.5 ? 1 : -1;\r\n                        })\r\n                    }\r\n                    for (let i = 0, tmpNode; i < nodesThisLevelArr.length | (tmpNode = nodesThisLevelArr[i]); i++) {\r\n                        t.children.push(tmpNode[1]);\r\n                    }\r\n                }\r\n\r\n                break;\r\n            default:\r\n                nodesThisLevel.forEach(function (tmpNode, ref) {\r\n                    t.children.push(tmpNode);\r\n                })\r\n        }\r\n\r\n        if (typeof this.grouping !== 'undefined') {\r\n            for (let i = 0, tmpNode; i < t.children.length | (tmpNode = t.children[i]); i++) {\r\n                this.grouping.generateTree(tmpNode, domMarks);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the animation order of marks\r\n     * @param {Object} t\r\n     * @param {Array} arr \r\n     */\r\n    getMarkOrder(t) {\r\n        let orderedMarks = [];\r\n        if (t != null) {\r\n            let queue = [];\r\n            queue.unshift(t);\r\n            while (queue.length != 0) {\r\n                let item = queue.shift();\r\n                let children = item.children;\r\n                if (children.length <= 0) {\r\n                    orderedMarks = [...orderedMarks, ...item.marks];\r\n                } else {\r\n                    for (let i = 0; i < children.length; i++)\r\n                        queue.push(children[i]);\r\n                }\r\n\r\n            }\r\n        }\r\n        return orderedMarks;\r\n    }\r\n\r\n    /**\r\n     * from bottom up, calculate the time specs of marks recursively\r\n     * @param {GroupingSpec} groupingSpec \r\n     * @param {Map} markAni : key:markId, value:time & action specs of the corresponding mark\r\n     * @param {Map} groupByM : key:markId, value:group reference\r\n     */\r\n    calTimeInGrouping(markAni, domMarks) {\r\n        let groupByRef = this.groupBy;\r\n\r\n        let groupByMap = new Map();//record the result of groupBy in this level. key:markId, value:group reference\r\n        markAni.forEach(function (ani, markId) {\r\n            let datum = domMarks.get(markId)['data-datum'];//datum stored in the tag\r\n            if (typeof domMarks.get(markId)[groupByRef] !== 'undefined') {\r\n                groupByMap.set(markId, domMarks.get(markId)[groupByRef]);\r\n            } else if (typeof domMarks.get(markId)[groupByRef] === 'undefined' && typeof datum[groupByRef] !== 'undefined') {\r\n                groupByMap.set(markId, datum[groupByRef]);\r\n            } else {\r\n                console.log('error: grouping by an unknown attribute');\r\n            }\r\n        })\r\n        if (typeof this.grouping !== 'undefined') {\r\n            this.grouping.calTimeInGrouping(markAni, domMarks);\r\n\r\n            //update time with upper grouping specs\r\n            let groupByArr = [...groupByMap];\r\n            let currentGroupRef = '';\r\n            let firstItemLastGroup, lastItemLastGroup;\r\n            let currentGroup = new Array();//record marks belong to current group\r\n            let lastGroup = new Map();\r\n            for (let i = 0; i < groupByArr.length; i++) {\r\n                let markId = groupByArr[i][0];\r\n                let groupRef = groupByArr[i][1];\r\n                if (groupRef !== currentGroupRef) {//come to the end of one group\r\n                    this.updateGroupingTime(firstItemLastGroup, lastItemLastGroup, lastGroup, currentGroup, markAni);\r\n                    firstItemLastGroup = currentGroup[0];\r\n                    lastItemLastGroup = currentGroup[currentGroup.length - 1];\r\n                    lastGroup = currentGroup;\r\n                    currentGroup = [];\r\n                    currentGroupRef = groupRef;\r\n                }\r\n                currentGroup.push(markId);\r\n            }\r\n\r\n            //deal with the last group\r\n            this.updateGroupingTime(firstItemLastGroup, lastItemLastGroup, lastGroup, currentGroup, markAni);\r\n        } else {//has come to the lowest level\r\n            let markAniArr = [...markAni.entries()];\r\n            markAniArr[0][1].startTime = 0;\r\n            for (let i = 1; i < markAniArr.length; i++) {\r\n                let tmpStart,\r\n                    previousStartTime = markAniArr[i - 1][1].startTime,\r\n                    previousEndTime = previousStartTime + markAniArr[i - 1][1].totalDuration;\r\n                switch (this.reference) {\r\n                    case TimingSpec.timingRef.previousStart:\r\n                        tmpStart = previousStartTime + this.delay;\r\n                        break;\r\n                    case TimingSpec.timingRef.previousEnd:\r\n                        tmpStart = previousEndTime + this.delay;\r\n                        break;\r\n                    case TimingSpec.timingRef.absolute:\r\n                        tmpStart = this.delay;\r\n                        break;\r\n                    default:\r\n                        tmpStart = previousStartTime + this.delay;\r\n                }\r\n                markAniArr[i][1].startTime = tmpStart;\r\n                markAni.set(markAniArr[i][0], markAniArr[i][1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    updateGroupingTime(firstItemLastGroup, lastItemLastGroup, lastGroup, currentGroup, markAni) {\r\n        let maxDuration = -10000, maxDurationItemLastGroup;\r\n        for (let i = 0, itemLastGroup; i < lastGroup.length | (itemLastGroup = lastGroup[i]); i++) {\r\n            if (markAni.get(itemLastGroup).startTime + markAni.get(itemLastGroup).totalDuration > maxDuration) {\r\n                maxDuration = markAni.get(itemLastGroup).startTime + markAni.get(itemLastGroup).totalDuration;\r\n                maxDurationItemLastGroup = itemLastGroup;\r\n            }\r\n        }\r\n\r\n\r\n        //update time acording to delay from the second group\r\n        if (typeof firstItemLastGroup !== 'undefined' && typeof maxDurationItemLastGroup !== 'undefined') {\r\n            let timeDiff = 0;\r\n            switch (this.reference) {\r\n                case TimingSpec.timingRef.previousStart:\r\n                    timeDiff = markAni.get(firstItemLastGroup).startTime - markAni.get(currentGroup[0]).startTime + this.delay;\r\n                    break;\r\n                case TimingSpec.timingRef.previousEnd:\r\n                    timeDiff = markAni.get(maxDurationItemLastGroup).startTime + markAni.get(maxDurationItemLastGroup).totalDuration - markAni.get(currentGroup[0]).startTime + this.delay;\r\n                    break;\r\n                case TimingSpec.timingRef.absolute:\r\n                    timeDiff = this.delay - markAni.get(currentGroup[0]).startTime;\r\n                    break;\r\n            }\r\n            for (let i = 0, markId; i < currentGroup.length | (markId = currentGroup[i]); i++) {\r\n                markAni.get(markId).startTime += timeDiff;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nGroupingSpec.orderTypes = {\r\n    ascending: 'ascending',\r\n    descending: 'descending',\r\n    random: 'random'\r\n}\r\n\r\nexport default GroupingSpec;","import ChartSpec from './ChartSpec.js';\r\nimport FacetSpec from './FacetSpec.js';\r\nimport TimingSpec from './TimingSpec.js';\r\nimport Animation from \"./Animation.js\";\r\nimport Util from './util/Util.js';\r\n\r\nclass AniChart {\r\n    constructor() {\r\n        this.chartSpecs;\r\n        this.facet;\r\n        this._animations;\r\n    }\r\n\r\n    set animations(aniJson) {\r\n        let idxAniJson = aniJson.map(tmpAni => {\r\n            tmpAni.chartIdx = 0\r\n            return tmpAni;\r\n        });\r\n        let chartNum = 0;//number of charts\r\n        if (this.facet) {\r\n            chartNum = this.facet.views[0].length;\r\n        } else {\r\n            chartNum = this.chartSpecs.length;\r\n        }\r\n        if (chartNum > 1) {//more than 1 input chart\r\n            for (let i = 1; i < chartNum - 1; i++) {\r\n                let tmpAniJson = Util.deepClone(aniJson);\r\n                tmpAniJson[0].reference = TimingSpec.timingRef.previousEnd;\r\n                let tmpIdxAniJson = tmpAniJson.map(tmpAni => {\r\n                    tmpAni.chartIdx = i;\r\n                    return tmpAni;\r\n                })\r\n                idxAniJson.push(...tmpIdxAniJson);\r\n            }\r\n        }\r\n        this._animations = idxAniJson;\r\n    }\r\n\r\n    get animations() {\r\n        return this._animations;\r\n    }\r\n\r\n    static loadSpec(url, callback) {\r\n        let xhr = new XMLHttpRequest(),\r\n            okStatus = document.location.protocol === \"file:\" ? 0 : 200;\r\n        xhr.open('GET', url, false);\r\n        xhr.overrideMimeType(\"text/html;charset=utf-8\");\r\n        xhr.send(null);\r\n        if (xhr.status === okStatus) {\r\n            let spec = xhr.responseText;\r\n            callback(JSON.parse(spec));\r\n        } else if (xhr.status === 404) {\r\n            console.log('can not find ' + url + ' ! Please check the url.');\r\n        }\r\n    }\r\n\r\n    init(spec) {\r\n        this.chartSpecs = [];\r\n        let aniChartObj = spec;\r\n\r\n        //deal with input charts\r\n        for (let i = 0; i < aniChartObj.charts.length; i++) {\r\n            let chartName = typeof aniChartObj.charts[i].id === 'undefined' ? 'chart' + i : aniChartObj.charts[i].id;\r\n            let tmpChart = new ChartSpec(chartName, aniChartObj.charts[i].source);\r\n            this.chartSpecs.push(tmpChart);\r\n        }\r\n\r\n        //init facet\r\n        if (aniChartObj.facet) {\r\n            this.facet = new FacetSpec(aniChartObj.facet.type, aniChartObj.facet.views);\r\n        }\r\n\r\n        ChartSpec.loadCharts(this.chartSpecs, this.facet);\r\n        let svgChart = ChartSpec.removeTransAndMerge();\r\n        document.getElementById('chartContainer').innerHTML = '';\r\n        document.getElementById('chartContainer').appendChild(svgChart);\r\n        let bBoxes = ChartSpec.getBBoxes();\r\n        let animateChart = ChartSpec.processAnimateChart(document.getElementById('chartContainer').innerHTML, bBoxes);\r\n        document.getElementById('videoContainer').innerHTML = '';\r\n        document.getElementById('videoContainer').appendChild(animateChart);\r\n\r\n        //deal with animations\r\n        this.animations = aniChartObj.animations;\r\n\r\n        if (Array.isArray(this.animations)) {\r\n            let lastAnimation;\r\n            for (let aniIdx = 0; aniIdx < this.animations.length; aniIdx++) {\r\n                let animationJson = this.animations[aniIdx];\r\n\r\n                //use the selection in animation to select marks and record dom attrs\r\n                let tmpContainer = document.createElement('div');\r\n                document.body.appendChild(tmpContainer);\r\n                tmpContainer.innerHTML = ChartSpec.charts[animationJson.chartIdx].outerHTML;\r\n                let marks = tmpContainer.querySelectorAll(animationJson.selection);\r\n\r\n                let usedChangedAttrs = [];\r\n                for (let i = 0; i < ChartSpec.changedAttrs.length; i++) {\r\n                    usedChangedAttrs.push(ChartSpec.changedAttrs[i]);\r\n                }\r\n\r\n                let animation = new Animation();\r\n                animation.translate(animationJson, usedChangedAttrs);//translate from json obj to Animation obj\r\n\r\n                let markIds = [];//record all ids of selected marks\r\n\r\n                if (marks.length > 0) {\r\n                    [].forEach.call(marks, function (mark) {\r\n                        if(mark.classList.contains('mark')){\r\n                            let markId = mark.getAttribute('id');\r\n                            markIds.push(markId);\r\n\r\n                            //process path\r\n                            if (mark.tagName === 'path') {//consider the linkage shape later\r\n                                let markJSON = Util.toJSON(mark);\r\n                                let transformedAttrs = Util.discretizePath(markJSON);\r\n\r\n                                if (transformedAttrs) {\r\n                                    if (transformedAttrs.type === 'lines') {\r\n                                        for (let i = 0; i < transformedAttrs.data.length; i++) {\r\n                                            markJSON.attr['x' + (1 + 2 * i)] = transformedAttrs.data[i][0][0];\r\n                                            markJSON.attr['y' + (1 + 2 * i)] = transformedAttrs.data[i][0][1];\r\n                                            markJSON.attr['x' + (2 + 2 * i)] = transformedAttrs.data[i][1][0];\r\n                                            markJSON.attr['y' + (2 + 2 * i)] = transformedAttrs.data[i][1][1];\r\n                                        }\r\n                                    } else {\r\n                                        let tfAttrsDataKeys = Object.keys(transformedAttrs.data);\r\n\r\n                                        for (let i = 0; i < tfAttrsDataKeys.length; i++) {\r\n                                            let tAttr = tfAttrsDataKeys[i];\r\n                                            if (tAttr === 'radius') {\r\n                                                if (transformedAttrs.data[tAttr].length > 1) {\r\n                                                    markJSON.attr.innerRadius = transformedAttrs.data[tAttr][0].rx + 1;\r\n                                                    markJSON.attr.outterRadius = transformedAttrs.data[tAttr][1].rx - 1;\r\n                                                } else {\r\n                                                    markJSON.attr.innerRadius = 0;\r\n                                                    markJSON.attr.outterRadius = transformedAttrs.data[tAttr][0].rx - 1;\r\n                                                }\r\n                                            } else {\r\n                                                markJSON.attr[tAttr] = transformedAttrs.data[tAttr];\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    mark = Util.toDOM(markJSON);\r\n                                }\r\n                            }\r\n\r\n                            let tmpDomAttrObj = {};\r\n                            let attrArr = [...mark.attributes];\r\n                            for (let i = 0; i < attrArr.length; i++) {\r\n                                let attrName = attrArr[i];\r\n                                tmpDomAttrObj[attrName.name] = mark.getAttribute(attrName.name);\r\n                            }\r\n                            let markDom = document.getElementById(markId);\r\n                            tmpDomAttrObj['bbWidth'] = markDom.getBBox().width;\r\n                            tmpDomAttrObj['bbHeight'] = markDom.getBBox().height;\r\n                            tmpDomAttrObj['bbX'] = markDom.getBBox().x;\r\n                            tmpDomAttrObj['bbY'] = markDom.getBBox().y;\r\n                            tmpDomAttrObj['content'] = mark.textContent;\r\n                            tmpDomAttrObj['id'] = markId;\r\n                            let dataDatumAttrValue = JSON.parse(mark.getAttribute('data-datum'));\r\n                            if (Array.isArray(dataDatumAttrValue)){\r\n                                dataDatumAttrValue = dataDatumAttrValue[0];\r\n                            }\r\n                            tmpDomAttrObj['data-datum'] = dataDatumAttrValue;\r\n                            if (mark.tagName === 'path' || mark.tagName === 'line') {\r\n                                tmpDomAttrObj['stroke-dasharray'] = document.getElementById(markId).getTotalLength();\r\n                                tmpDomAttrObj['stroke-dashoffset'] = document.getElementById(markId).getTotalLength();\r\n                            }\r\n                            animation.domMarks.set(markId, tmpDomAttrObj);\r\n                        }\r\n                    })\r\n                }\r\n                animation.calAniTime(markIds, lastAnimation);\r\n                lastAnimation = animation;\r\n                document.body.removeChild(tmpContainer);\r\n            }\r\n        }\r\n    }\r\n\r\n    render() {\r\n        Animation.renderAnimation();\r\n    }\r\n}\r\n\r\nexport default AniChart;","import TimingSpec from './TimingSpec.js';\r\nimport Animation from './Animation.js';\r\nimport Util from './util/Util.js';\r\n\r\nclass Renderer {\r\n    constructor() { }\r\n\r\n    /**\r\n     * get the corresponding frame of current time from Animation.frames\r\n     * and update the dom attrs according to the recorded attrs status in that frame\r\n     * @param {number} : time in ms\r\n     */\r\n    static renderFrame(ctime) {\r\n        let frame = Animation.renderFrame(ctime);\r\n        if (typeof frame === 'undefined') {\r\n            return false;\r\n        }\r\n        for (let i = 0, markStatus; i < frame.length | (markStatus = frame[i]); i++) {\r\n            markStatus[1].forEach(function (singleStatus, attrName) {\r\n                let aniId = '';\r\n                if (singleStatus.type === 'mark') {\r\n                    aniId = 'ani' + markStatus[0];\r\n                    switch (singleStatus.attrName) {\r\n                        case 'textContent':\r\n                            if (Util.checkHTML(singleStatus.value)) {\r\n                                let tmpDom = Util.strToDomNode(singleStatus.value);\r\n                                document.getElementById(aniId).appendChild(tmpDom);\r\n                            } else {\r\n                                document.getElementById(aniId).innerHTML = singleStatus.value;\r\n                                document.getElementById(aniId).textContent = singleStatus.value;\r\n                            }\r\n                            break;\r\n                        case 'stroke-dashoffset':\r\n                            document.getElementById(aniId).setAttributeNS(null, 'stroke-dasharray', document.getElementById(aniId).getTotalLength());\r\n                            document.getElementById(aniId).setAttributeNS(null, singleStatus.attrName, singleStatus.value);\r\n                            break;\r\n                        case 'x':\r\n                        case 'y':\r\n                            document.getElementById(aniId).setAttributeNS(null, singleStatus.attrName, singleStatus.value);\r\n                            if (document.getElementById('animaskCover' + markStatus[0])) {\r\n                                if (singleStatus.attrName === 'y' && document.getElementById(markStatus[0]).tagName === 'text') {\r\n                                    document.getElementById('animaskCover' + markStatus[0]).setAttributeNS(null, singleStatus.attrName, singleStatus.value - parseFloat(document.getElementById('animaskBg' + markStatus[0]).getAttributeNS(null, 'height')));\r\n                                } else {\r\n                                    document.getElementById('animaskCover' + markStatus[0]).setAttributeNS(null, singleStatus.attrName, singleStatus.value);\r\n                                }\r\n                            }\r\n                            document.getElementById(aniId).setAttributeNS(null, singleStatus.attrName, singleStatus.value);\r\n                            break;\r\n                        default:\r\n                            document.getElementById(aniId).setAttributeNS(null, singleStatus.attrName, singleStatus.value);\r\n                    }\r\n                    //change animaskBgmark with the mark\r\n                    let aniMarkBgId = 'animaskBg' + markStatus[0],\r\n                        currentAniMarkBBox = document.getElementById(aniId).getBBox();\r\n                    document.getElementById(aniMarkBgId).setAttributeNS(null, 'x', currentAniMarkBBox.x - 1);\r\n                    document.getElementById(aniMarkBgId).setAttributeNS(null, 'y', currentAniMarkBBox.y - 1);\r\n                    document.getElementById(aniMarkBgId).setAttributeNS(null, 'width', currentAniMarkBBox.width + 2);\r\n                    document.getElementById(aniMarkBgId).setAttributeNS(null, 'height', currentAniMarkBBox.height + 2);\r\n                } else if (singleStatus.type === 'mask') {\r\n                    aniId = 'animask' + markStatus[0];\r\n                    /*\r\n                     *1st. check whether the mask is added \r\n                     *2nd. check whether the mask is the right shape\r\n                     *3rd. set the attributes of the mask\r\n                     */\r\n                    let testAniMCover = document.querySelectorAll('#' + aniId + ' [id^=\"animaskCover\"]');\r\n                    switch (singleStatus.animationType) {\r\n                        case 'fade':\r\n                        case 'move':\r\n                        case 'wipe':\r\n                        case 'custom':\r\n                            if (testAniMCover.length > 0) {//already has a mask cover\r\n                                let aniMCover = document.getElementById('animaskCover' + markStatus[0]);\r\n                                if (aniMCover.getAttribute('maskType') !== 'rect') {//current cover is not the right shape\r\n                                    aniMCover.parentNode.removeChild(aniMCover);\r\n                                    let rect = Renderer.generateMaskCover(Renderer.coverTypes.rect, markStatus[0], singleStatus.attrName, singleStatus.value);\r\n                                    document.getElementById(aniId).appendChild(rect);\r\n                                } else {\r\n                                    document.getElementById('animaskCover' + markStatus[0]).setAttributeNS(null, singleStatus.attrName, singleStatus.value);\r\n                                }\r\n                            } else {//don't have a mask cover yet\r\n                                let rect = Renderer.generateMaskCover(Renderer.coverTypes.rect, markStatus[0], singleStatus.attrName, singleStatus.value);\r\n                                document.getElementById(aniId).appendChild(rect);\r\n                            }\r\n                            break;\r\n                        case 'circle':\r\n                        case 'wheel':\r\n                            let d = Util.arc(singleStatus.value.cx, singleStatus.value.cy, singleStatus.value.innerRadius, singleStatus.value.outterRadius - 6, singleStatus.value.startAngle, singleStatus.value.endAngle);\r\n                            if (testAniMCover.length > 0) {//already has a mask cover\r\n                                let aniMCover = document.getElementById('animaskCover' + markStatus[0]);\r\n                                if (aniMCover.getAttribute('maskType') !== 'wedge') {//current cover is not the right shape\r\n                                    aniMCover.parentNode.removeChild(aniMCover);\r\n                                    let wedge = Renderer.generateMaskCover(Renderer.coverTypes.path, markStatus[0], 'd', d);\r\n                                    document.getElementById(aniId).appendChild(wedge);\r\n                                } else {\r\n                                    document.getElementById('animaskCover' + markStatus[0]).setAttributeNS(null, 'd', d);\r\n                                }\r\n                            } else {//don't have a mask cover yet\r\n                                let wedge = Renderer.generateMaskCover(Renderer.coverTypes.path, markStatus[0], 'd', d);\r\n                                document.getElementById(aniId).appendChild(wedge);\r\n                            }\r\n                            break;\r\n                        case 'mistake':\r\n                            if (testAniMCover.length > 0) {//already has a mask cover\r\n                                document.getElementById('animaskCover' + markStatus[0]).setAttributeNS(null, singleStatus.attrName, singleStatus.value);\r\n                            }\r\n                            break;\r\n                    }\r\n                } else {\r\n                    console.log('this status has no type');\r\n                }\r\n            })\r\n        }\r\n        return true;\r\n    }\r\n\r\n    static generateMaskCover(coverType, markId, updateAttrName, updateAttrValue) {\r\n        let maskCover;\r\n        switch (coverType) {\r\n            case Renderer.coverTypes.rect:\r\n                maskCover = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n                maskCover.setAttributeNS(null, 'maskType', 'rect');\r\n                maskCover.setAttributeNS(null, 'x', document.getElementById('animaskBg' + markId).getAttribute('x'));\r\n                maskCover.setAttributeNS(null, 'y', document.getElementById('animaskBg' + markId).getAttribute('y'));\r\n                maskCover.setAttributeNS(null, 'width', document.getElementById('animaskBg' + markId).getAttribute('width'));\r\n                maskCover.setAttributeNS(null, 'height', document.getElementById('animaskBg' + markId).getAttribute('height'));\r\n                break;\r\n            case Renderer.coverTypes.path:\r\n                maskCover = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n                maskCover.setAttributeNS(null, 'maskType', 'wedge');\r\n                if (document.getElementById(markId).getAttribute('transform')) {\r\n                    maskCover.setAttributeNS(null, 'tranform', document.getElementById(markId).getAttribute('transform'));\r\n                }\r\n                break;\r\n        }\r\n        maskCover.setAttributeNS(null, 'id', 'animaskCover' + markId);\r\n        maskCover.setAttributeNS(null, 'fill', '#000');\r\n        maskCover.setAttributeNS(null, 'stroke', '#000');\r\n        maskCover.setAttributeNS(null, 'stroke-width', 4);\r\n        if (updateAttrName !== 'stroke')\r\n            maskCover.setAttributeNS(null, updateAttrName, updateAttrValue);\r\n        return maskCover;\r\n    }\r\n\r\n    static resetCover() {\r\n        let animaskCovers = document.querySelectorAll('[id^=\"animaskCover\"]');\r\n        if (animaskCovers.length > 0) {\r\n            [].forEach.call(animaskCovers, (mc) => {\r\n                mc.parentNode.removeChild(mc);\r\n            })\r\n        }\r\n    }\r\n\r\n    static play() {\r\n        let time = 0;\r\n        let animationInterval = setInterval(() => {\r\n            //render this frame\r\n            time = parseInt(time / (1000 / TimingSpec.FRAME_RATE)) * (1000 / TimingSpec.FRAME_RATE);\r\n            let locatedFrame = this.renderFrame(time);\r\n\r\n            time += 1000 / TimingSpec.FRAME_RATE;\r\n            if (time > Animation.wholeEndTime || !locatedFrame) {\r\n                clearInterval(animationInterval);\r\n                animationInterval = 'undefined';\r\n                time = 0;\r\n            }\r\n        }, 1000 / TimingSpec.FRAME_RATE);\r\n    }\r\n}\r\n\r\nRenderer.coverTypes = {\r\n    rect: Symbol(),\r\n    path: Symbol()\r\n};\r\n\r\nexport default Renderer;"],"sourceRoot":""}